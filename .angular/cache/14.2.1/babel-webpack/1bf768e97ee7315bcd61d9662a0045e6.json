{"ast":null,"code":"import _assertThisInitialized from \"C:/Users/\\u05D0\\u05D1\\u05D9\\u05D1/Documents/\\u05DC\\u05D9\\u05DE\\u05D5\\u05D3\\u05D9\\u05DD/\\u05D4\\u05D2\\u05E9\\u05D4 \\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/Client22/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _createForOfIteratorHelper from \"C:/Users/\\u05D0\\u05D1\\u05D9\\u05D1/Documents/\\u05DC\\u05D9\\u05DE\\u05D5\\u05D3\\u05D9\\u05DD/\\u05D4\\u05D2\\u05E9\\u05D4 \\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/Client22/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/\\u05D0\\u05D1\\u05D9\\u05D1/Documents/\\u05DC\\u05D9\\u05DE\\u05D5\\u05D3\\u05D9\\u05DD/\\u05D4\\u05D2\\u05E9\\u05D4 \\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/Client22/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"C:/Users/\\u05D0\\u05D1\\u05D9\\u05D1/Documents/\\u05DC\\u05D9\\u05DE\\u05D5\\u05D3\\u05D9\\u05DD/\\u05D4\\u05D2\\u05E9\\u05D4 \\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/Client22/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _inherits from \"C:/Users/\\u05D0\\u05D1\\u05D9\\u05D1/Documents/\\u05DC\\u05D9\\u05DE\\u05D5\\u05D3\\u05D9\\u05DD/\\u05D4\\u05D2\\u05E9\\u05D4 \\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/Client22/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/\\u05D0\\u05D1\\u05D9\\u05D1/Documents/\\u05DC\\u05D9\\u05DE\\u05D5\\u05D3\\u05D9\\u05DD/\\u05D4\\u05D2\\u05E9\\u05D4 \\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/Client22/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createClass from \"C:/Users/\\u05D0\\u05D1\\u05D9\\u05D1/Documents/\\u05DC\\u05D9\\u05DE\\u05D5\\u05D3\\u05D9\\u05DD/\\u05D4\\u05D2\\u05E9\\u05D4 \\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/Client22/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/\\u05D0\\u05D1\\u05D9\\u05D1/Documents/\\u05DC\\u05D9\\u05DE\\u05D5\\u05D3\\u05D9\\u05DD/\\u05D4\\u05D2\\u05E9\\u05D4 \\u05EA\\u05DB\\u05E0\\u05D5\\u05EA/Client22/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n\n/**\n * @license Angular v6.1.10\n * (c) 2010-2018 Google, Inc. https://angular.io/\n * License: MIT\n */\nimport { Component, ɵisObservable, ɵisPromise, NgModuleRef, InjectionToken, NgModuleFactory, NgZone, isDevMode, ɵConsole, Attribute, Directive, ElementRef, HostBinding, HostListener, Input, Renderer2, ChangeDetectorRef, ContentChildren, ComponentFactoryResolver, EventEmitter, Output, ViewContainerRef, Compiler, Injectable, Injector, NgModuleFactoryLoader, ANALYZE_FOR_ENTRY_COMPONENTS, APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationRef, Inject, NgModule, NgProbeToken, Optional, SkipSelf, SystemJsNgModuleLoader, Version } from '@angular/core';\nimport { from, of, EmptyError, Observable, BehaviorSubject, Subject } from 'rxjs';\nimport { concatAll, every, last, map, mergeAll, catchError, first, mergeMap, concatMap, reduce, filter } from 'rxjs/operators';\nimport { LocationStrategy, APP_BASE_HREF, HashLocationStrategy, LOCATION_INITIALIZED, Location, PathLocationStrategy, PlatformLocation, ViewportScroller } from '@angular/common';\nimport { ɵgetDOM } from '@angular/platform-browser';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Base for events the Router goes through, as opposed to events tied to a specific\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\n *\n * Example:\n *\n * ```\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.filter(e => e instanceof RouterEvent).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * \\@experimental\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nvar RouterEvent = /*#__PURE__*/_createClass(\n/**\n * @param {?} id\n * @param {?} url\n */\nfunction RouterEvent(id, url) {\n  _classCallCheck(this, RouterEvent);\n\n  this.id = id;\n  this.url = url;\n});\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation starts.\n *\n *\n */\n\n\nvar NavigationStart = /*#__PURE__*/function (_RouterEvent) {\n  _inherits(NavigationStart, _RouterEvent);\n\n  var _super = _createSuper(NavigationStart);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?=} navigationTrigger\n   * @param {?=} restoredState\n   */\n  function NavigationStart(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url) {\n    var _this;\n\n    var navigationTrigger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'imperative';\n    var restoredState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, NavigationStart);\n\n    _this = _super.call(this, id, url);\n    _this.navigationTrigger = navigationTrigger;\n    _this.restoredState = restoredState;\n    return _this;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"')\");\n    }\n  }]);\n\n  return NavigationStart;\n}(RouterEvent);\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation ends successfully.\n *\n *\n */\n\n\nvar NavigationEnd = /*#__PURE__*/function (_RouterEvent2) {\n  _inherits(NavigationEnd, _RouterEvent2);\n\n  var _super2 = _createSuper(NavigationEnd);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   */\n  function NavigationEnd(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects) {\n    var _this2;\n\n    _classCallCheck(this, NavigationEnd);\n\n    _this2 = _super2.call(this, id, url);\n    _this2.urlAfterRedirects = urlAfterRedirects;\n    return _this2;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"')\");\n    }\n  }]);\n\n  return NavigationEnd;\n}(RouterEvent);\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation is canceled.\n *\n *\n */\n\n\nvar NavigationCancel = /*#__PURE__*/function (_RouterEvent3) {\n  _inherits(NavigationCancel, _RouterEvent3);\n\n  var _super3 = _createSuper(NavigationCancel);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} reason\n   */\n  function NavigationCancel(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, reason) {\n    var _this3;\n\n    _classCallCheck(this, NavigationCancel);\n\n    _this3 = _super3.call(this, id, url);\n    _this3.reason = reason;\n    return _this3;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationCancel, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationCancel(id: \".concat(this.id, \", url: '\").concat(this.url, \"')\");\n    }\n  }]);\n\n  return NavigationCancel;\n}(RouterEvent);\n/**\n * \\@description\n *\n * Represents an event triggered when a navigation fails due to an unexpected error.\n *\n *\n */\n\n\nvar NavigationError = /*#__PURE__*/function (_RouterEvent4) {\n  _inherits(NavigationError, _RouterEvent4);\n\n  var _super4 = _createSuper(NavigationError);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} error\n   */\n  function NavigationError(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, error) {\n    var _this4;\n\n    _classCallCheck(this, NavigationError);\n\n    _this4 = _super4.call(this, id, url);\n    _this4.error = error;\n    return _this4;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationError, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationError(id: \".concat(this.id, \", url: '\").concat(this.url, \"', error: \").concat(this.error, \")\");\n    }\n  }]);\n\n  return NavigationError;\n}(RouterEvent);\n/**\n * \\@description\n *\n * Represents an event triggered when routes are recognized.\n *\n *\n */\n\n\nvar RoutesRecognized = /*#__PURE__*/function (_RouterEvent5) {\n  _inherits(RoutesRecognized, _RouterEvent5);\n\n  var _super5 = _createSuper(RoutesRecognized);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function RoutesRecognized(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this5;\n\n    _classCallCheck(this, RoutesRecognized);\n\n    _this5 = _super5.call(this, id, url);\n    _this5.urlAfterRedirects = urlAfterRedirects;\n    _this5.state = state;\n    return _this5;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(RoutesRecognized, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RoutesRecognized(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return RoutesRecognized;\n}(RouterEvent);\n/**\n * \\@description\n *\n * Represents the start of the Guard phase of routing.\n *\n * \\@experimental\n */\n\n\nvar GuardsCheckStart = /*#__PURE__*/function (_RouterEvent6) {\n  _inherits(GuardsCheckStart, _RouterEvent6);\n\n  var _super6 = _createSuper(GuardsCheckStart);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function GuardsCheckStart(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this6;\n\n    _classCallCheck(this, GuardsCheckStart);\n\n    _this6 = _super6.call(this, id, url);\n    _this6.urlAfterRedirects = urlAfterRedirects;\n    _this6.state = state;\n    return _this6;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(GuardsCheckStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"GuardsCheckStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return GuardsCheckStart;\n}(RouterEvent);\n/**\n * \\@description\n *\n * Represents the end of the Guard phase of routing.\n *\n * \\@experimental\n */\n\n\nvar GuardsCheckEnd = /*#__PURE__*/function (_RouterEvent7) {\n  _inherits(GuardsCheckEnd, _RouterEvent7);\n\n  var _super7 = _createSuper(GuardsCheckEnd);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   * @param {?} shouldActivate\n   */\n  function GuardsCheckEnd(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state, shouldActivate) {\n    var _this7;\n\n    _classCallCheck(this, GuardsCheckEnd);\n\n    _this7 = _super7.call(this, id, url);\n    _this7.urlAfterRedirects = urlAfterRedirects;\n    _this7.state = state;\n    _this7.shouldActivate = shouldActivate;\n    return _this7;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(GuardsCheckEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"GuardsCheckEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \", shouldActivate: \").concat(this.shouldActivate, \")\");\n    }\n  }]);\n\n  return GuardsCheckEnd;\n}(RouterEvent);\n/**\n * \\@description\n *\n * Represents the start of the Resolve phase of routing. The timing of this\n * event may change, thus it's experimental. In the current iteration it will run\n * in the \"resolve\" phase whether there's things to resolve or not. In the future this\n * behavior may change to only run when there are things to be resolved.\n *\n * \\@experimental\n */\n\n\nvar ResolveStart = /*#__PURE__*/function (_RouterEvent8) {\n  _inherits(ResolveStart, _RouterEvent8);\n\n  var _super8 = _createSuper(ResolveStart);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function ResolveStart(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this8;\n\n    _classCallCheck(this, ResolveStart);\n\n    _this8 = _super8.call(this, id, url);\n    _this8.urlAfterRedirects = urlAfterRedirects;\n    _this8.state = state;\n    return _this8;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ResolveStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ResolveStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return ResolveStart;\n}(RouterEvent);\n/**\n * \\@description\n *\n * Represents the end of the Resolve phase of routing. See note on\n * `ResolveStart` for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ResolveEnd = /*#__PURE__*/function (_RouterEvent9) {\n  _inherits(ResolveEnd, _RouterEvent9);\n\n  var _super9 = _createSuper(ResolveEnd);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function ResolveEnd(\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this9;\n\n    _classCallCheck(this, ResolveEnd);\n\n    _this9 = _super9.call(this, id, url);\n    _this9.urlAfterRedirects = urlAfterRedirects;\n    _this9.state = state;\n    return _this9;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ResolveEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ResolveEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return ResolveEnd;\n}(RouterEvent);\n/**\n * \\@description\n *\n * Represents an event triggered before lazy loading a route config.\n *\n * \\@experimental\n */\n\n\nvar RouteConfigLoadStart = /*#__PURE__*/function () {\n  /**\n   * @param {?} route\n   */\n  function RouteConfigLoadStart(route) {\n    _classCallCheck(this, RouteConfigLoadStart);\n\n    this.route = route;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouteConfigLoadStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RouteConfigLoadStart(path: \".concat(this.route.path, \")\");\n    }\n  }]);\n\n  return RouteConfigLoadStart;\n}();\n/**\n * \\@description\n *\n * Represents an event triggered when a route has been lazy loaded.\n *\n * \\@experimental\n */\n\n\nvar RouteConfigLoadEnd = /*#__PURE__*/function () {\n  /**\n   * @param {?} route\n   */\n  function RouteConfigLoadEnd(route) {\n    _classCallCheck(this, RouteConfigLoadEnd);\n\n    this.route = route;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouteConfigLoadEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RouteConfigLoadEnd(path: \".concat(this.route.path, \")\");\n    }\n  }]);\n\n  return RouteConfigLoadEnd;\n}();\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationEnd` for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ChildActivationStart = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ChildActivationStart(snapshot) {\n    _classCallCheck(this, ChildActivationStart);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ChildActivationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ChildActivationStart(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ChildActivationStart;\n}();\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationStart` for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ChildActivationEnd = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ChildActivationEnd(snapshot) {\n    _classCallCheck(this, ChildActivationEnd);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ChildActivationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ChildActivationEnd(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ChildActivationEnd;\n}();\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationEnd` for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ActivationStart = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ActivationStart(snapshot) {\n    _classCallCheck(this, ActivationStart);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ActivationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ActivationStart(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ActivationStart;\n}();\n/**\n * \\@description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationStart` for use of this experimental API.\n *\n * \\@experimental\n */\n\n\nvar ActivationEnd = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ActivationEnd(snapshot) {\n    _classCallCheck(this, ActivationEnd);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ActivationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ActivationEnd(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ActivationEnd;\n}();\n/**\n * \\@description\n *\n * Represents a scrolling event.\n */\n\n\nvar Scroll = /*#__PURE__*/function () {\n  /**\n   * @param {?} routerEvent\n   * @param {?} position\n   * @param {?} anchor\n   */\n  function Scroll(\n  /** @docsNotRequired */\n  routerEvent,\n  /** @docsNotRequired */\n  position,\n  /** @docsNotRequired */\n  anchor) {\n    _classCallCheck(this, Scroll);\n\n    this.routerEvent = routerEvent;\n    this.position = position;\n    this.anchor = anchor;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Scroll, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var pos = this.position ? \"\".concat(this.position[0], \", \").concat(this.position[1]) : null;\n      return \"Scroll(anchor: '\".concat(this.anchor, \"', position: '\").concat(pos, \"')\");\n    }\n  }]);\n\n  return Scroll;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\n\n\nvar EmptyOutletComponent = /*#__PURE__*/(function () {\n  var EmptyOutletComponent = /*#__PURE__*/_createClass(function EmptyOutletComponent() {\n    _classCallCheck(this, EmptyOutletComponent);\n  });\n\n  EmptyOutletComponent.ɵfac = function EmptyOutletComponent_Factory(t) {\n    return new (t || EmptyOutletComponent)();\n  };\n\n  EmptyOutletComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: EmptyOutletComponent,\n    selectors: [[\"ng-component\"]],\n    decls: 1,\n    vars: 0,\n    template: function EmptyOutletComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"router-outlet\");\n      }\n    },\n    dependencies: function dependencies() {\n      return [RouterOutlet];\n    },\n    encapsulation: 2\n  });\n  return EmptyOutletComponent;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** *\n * \\@description\n *\n * Name of the primary outlet.\n *\n *\n  @type {?} */\n\n\nvar PRIMARY_OUTLET = 'primary';\n\nvar ParamsAsMap = /*#__PURE__*/function () {\n  /**\n   * @param {?} params\n   */\n  function ParamsAsMap(params) {\n    _classCallCheck(this, ParamsAsMap);\n\n    this.params = params || {};\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  _createClass(ParamsAsMap, [{\n    key: \"has\",\n    value: function has(name) {\n      return this.params.hasOwnProperty(name);\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      if (this.has(name)) {\n        /** @type {?} */\n        var v = this.params[name];\n        return Array.isArray(v) ? v[0] : v;\n      }\n\n      return null;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll(name) {\n      if (this.has(name)) {\n        /** @type {?} */\n        var v = this.params[name];\n        return Array.isArray(v) ? v : [v];\n      }\n\n      return [];\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return Object.keys(this.params);\n    }\n  }]);\n\n  return ParamsAsMap;\n}();\n/**\n * Convert a `Params` instance to a `ParamMap`.\n *\n *\n * @param {?} params\n * @return {?}\n */\n\n\nfunction convertToParamMap(params) {\n  return new ParamsAsMap(params);\n}\n/** @type {?} */\n\n\nvar NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n/**\n * @param {?} message\n * @return {?}\n */\n\nfunction navigationCancelingError(message) {\n  /** @type {?} */\n  var error = Error('NavigationCancelingError: ' + message);\n\n  /** @type {?} */\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  return error;\n}\n/**\n * @param {?} error\n * @return {?}\n */\n\n\nfunction isNavigationCancelingError(error) {\n  return error &&\n  /** @type {?} */\n  error[NAVIGATION_CANCELING_ERROR];\n}\n/**\n * @param {?} segments\n * @param {?} segmentGroup\n * @param {?} route\n * @return {?}\n */\n\n\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n  /** @type {?} */\n  var parts =\n  /** @type {?} */\n  route.path.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n  /** @type {?} */\n\n\n  var posParams = {}; // Check each config part against the actual URL\n\n  for (var index = 0; index < parts.length; index++) {\n    /** @type {?} */\n    var part = parts[index];\n    /** @type {?} */\n\n    var segment = segments[index];\n    /** @type {?} */\n\n    var isParameter = part.startsWith(':');\n\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {\n    consumed: segments.slice(0, parts.length),\n    posParams: posParams\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nvar LoadedRouterConfig = /*#__PURE__*/_createClass(\n/**\n * @param {?} routes\n * @param {?} module\n */\nfunction LoadedRouterConfig(routes, module) {\n  _classCallCheck(this, LoadedRouterConfig);\n\n  this.routes = routes;\n  this.module = module;\n});\n/**\n * @param {?} config\n * @param {?=} parentPath\n * @return {?}\n */\n\n\nfunction validateConfig(config) {\n  var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  // forEach doesn't iterate undefined values\n  for (var i = 0; i < config.length; i++) {\n    /** @type {?} */\n    var route = config[i];\n    /** @type {?} */\n\n    var fullPath = getFullPath(parentPath, route);\n    validateNode(route, fullPath);\n  }\n}\n/**\n * @param {?} route\n * @param {?} fullPath\n * @return {?}\n */\n\n\nfunction validateNode(route, fullPath) {\n  if (!route) {\n    throw new Error(\"\\n      Invalid configuration of route '\".concat(fullPath, \"': Encountered undefined route.\\n      The reason might be an extra comma.\\n\\n      Example:\\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \"));\n  }\n\n  if (Array.isArray(route)) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': Array cannot be specified\"));\n  }\n\n  if (!route.component && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': a componentless route without children or loadChildren cannot have a named outlet set\"));\n  }\n\n  if (route.redirectTo && route.children) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and children cannot be used together\"));\n  }\n\n  if (route.redirectTo && route.loadChildren) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and loadChildren cannot be used together\"));\n  }\n\n  if (route.children && route.loadChildren) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': children and loadChildren cannot be used together\"));\n  }\n\n  if (route.redirectTo && route.component) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and component cannot be used together\"));\n  }\n\n  if (route.path && route.matcher) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': path and matcher cannot be used together\"));\n  }\n\n  if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"'. One of the following must be provided: component, redirectTo, children or loadChildren\"));\n  }\n\n  if (route.path === void 0 && route.matcher === void 0) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': routes must have either a path or a matcher specified\"));\n  }\n\n  if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': path cannot start with a slash\"));\n  }\n\n  if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n    /** @type {?} */\n    var exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n    throw new Error(\"Invalid configuration of route '{path: \\\"\".concat(fullPath, \"\\\", redirectTo: \\\"\").concat(route.redirectTo, \"\\\"}': please provide 'pathMatch'. \").concat(exp));\n  }\n\n  if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': pathMatch can only be set to 'prefix' or 'full'\"));\n  }\n\n  if (route.children) {\n    validateConfig(route.children, fullPath);\n  }\n}\n/**\n * @param {?} parentPath\n * @param {?} currentRoute\n * @return {?}\n */\n\n\nfunction getFullPath(parentPath, currentRoute) {\n  if (!currentRoute) {\n    return parentPath;\n  }\n\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return \"\".concat(parentPath, \"/\");\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return \"\".concat(parentPath, \"/\").concat(currentRoute.path);\n  }\n}\n/**\n * Makes a copy of the config and adds any default required properties.\n * @param {?} r\n * @return {?}\n */\n\n\nfunction standardizeConfig(r) {\n  /** @type {?} */\n  var children = r.children && r.children.map(standardizeConfig);\n  /** @type {?} */\n\n  var c = children ? Object.assign({}, r, {\n    children: children\n  }) : Object.assign({}, r);\n\n  if (!c.component && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {\n    c.component = EmptyOutletComponent;\n  }\n\n  return c;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction shallowEqualArrays(a, b) {\n  if (a.length !== b.length) return false;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction shallowEqual(a, b) {\n  /** @type {?} */\n  var k1 = Object.keys(a);\n  /** @type {?} */\n\n  var k2 = Object.keys(b);\n\n  if (k1.length != k2.length) {\n    return false;\n  }\n  /** @type {?} */\n\n\n  var key;\n\n  for (var i = 0; i < k1.length; i++) {\n    key = k1[i];\n\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Flattens single-level nested arrays.\n * @template T\n * @param {?} arr\n * @return {?}\n */\n\n\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n/**\n * Return the last element of an array.\n * @template T\n * @param {?} a\n * @return {?}\n */\n\n\nfunction last$1(a) {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n/**\n * @template K, V\n * @param {?} map\n * @param {?} callback\n * @return {?}\n */\n\n\nfunction forEach(map$$1, callback) {\n  for (var prop in map$$1) {\n    if (map$$1.hasOwnProperty(prop)) {\n      callback(map$$1[prop], prop);\n    }\n  }\n}\n/**\n * @template A, B\n * @param {?} obj\n * @param {?} fn\n * @return {?}\n */\n\n\nfunction waitForMap(obj, fn) {\n  if (Object.keys(obj).length === 0) {\n    return of({});\n  }\n  /** @type {?} */\n\n\n  var waitHead = [];\n  /** @type {?} */\n\n  var waitTail = [];\n  /** @type {?} */\n\n  var res = {};\n  forEach(obj, function (a, k) {\n    /** @type {?} */\n    var mapped = fn(k, a).pipe(map(function (r) {\n      return res[k] = r;\n    }));\n\n    if (k === PRIMARY_OUTLET) {\n      waitHead.push(mapped);\n    } else {\n      waitTail.push(mapped);\n    }\n  }); // Closure compiler has problem with using spread operator here. So just using Array.concat.\n\n  return of.apply(null, waitHead.concat(waitTail)).pipe(concatAll(), last(), map(function () {\n    return res;\n  }));\n}\n/**\n * ANDs Observables by merging all input observables, reducing to an Observable verifying all\n * input Observables return `true`.\n * @param {?} observables\n * @return {?}\n */\n\n\nfunction andObservables(observables) {\n  return observables.pipe(mergeAll(), every(function (result) {\n    return result === true;\n  }));\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\n\n\nfunction wrapIntoObservable(value) {\n  if (ɵisObservable(value)) {\n    return value;\n  }\n\n  if (ɵisPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(\n  /** @type {?} */\n  value);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @return {?}\n */\n\n\nfunction createEmptyUrlTree() {\n  return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} exact\n * @return {?}\n */\n\n\nfunction containsTree(container, containee, exact) {\n  if (exact) {\n    return equalQueryParams(container.queryParams, containee.queryParams) && equalSegmentGroups(container.root, containee.root);\n  }\n\n  return containsQueryParams(container.queryParams, containee.queryParams) && containsSegmentGroup(container.root, containee.root);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction equalQueryParams(container, containee) {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction equalSegmentGroups(container, containee) {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n\n  for (var c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c])) return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction containsQueryParams(container, containee) {\n  // TODO: This does not handle array params correctly.\n  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(function (key) {\n    return containee[key] === container[key];\n  });\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction containsSegmentGroup(container, containee) {\n  return containsSegmentGroupHelper(container, containee, containee.segments);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} containeePaths\n * @return {?}\n */\n\n\nfunction containsSegmentGroupHelper(container, containee, containeePaths) {\n  if (container.segments.length > containeePaths.length) {\n    /** @type {?} */\n    var current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n\n    for (var c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c])) return false;\n    }\n\n    return true;\n  } else {\n    /** @type {?} */\n    var _current = containeePaths.slice(0, container.segments.length);\n    /** @type {?} */\n\n\n    var next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, _current)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n  }\n}\n/**\n * \\@description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * \\@usageNotes\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n *\n */\n\n\nvar UrlTree = /*#__PURE__*/function () {\n  /**\n   * \\@internal\n   * @param {?} root\n   * @param {?} queryParams\n   * @param {?} fragment\n   */\n  function UrlTree(root, queryParams, fragment) {\n    _classCallCheck(this, UrlTree);\n\n    this.root = root;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(UrlTree, [{\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = convertToParamMap(this.queryParams);\n      }\n\n      return this._queryParamMap;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return DEFAULT_SERIALIZER.serialize(this);\n    }\n  }]);\n\n  return UrlTree;\n}();\n/**\n * \\@description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n *\n */\n\n\nvar UrlSegmentGroup = /*#__PURE__*/function () {\n  /**\n   * @param {?} segments\n   * @param {?} children\n   */\n  function UrlSegmentGroup(segments, children) {\n    var _this10 = this;\n\n    _classCallCheck(this, UrlSegmentGroup);\n\n    this.segments = segments;\n    this.children = children;\n    /**\n     * The parent node in the url tree\n     */\n\n    this.parent = null;\n    forEach(children, function (v, k) {\n      return v.parent = _this10;\n    });\n  }\n  /**\n   * Whether the segment has child segments\n   * @return {?}\n   */\n\n\n  _createClass(UrlSegmentGroup, [{\n    key: \"hasChildren\",\n    value: function hasChildren() {\n      return this.numberOfChildren > 0;\n    }\n    /**\n     * Number of child segments\n     * @return {?}\n     */\n\n  }, {\n    key: \"numberOfChildren\",\n    get: function get() {\n      return Object.keys(this.children).length;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return serializePaths(this);\n    }\n  }]);\n\n  return UrlSegmentGroup;\n}();\n/**\n * \\@description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * \\@usageNotes\n *  ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n *\n */\n\n\nvar UrlSegment = /*#__PURE__*/function () {\n  /**\n   * @param {?} path\n   * @param {?} parameters\n   */\n  function UrlSegment(path, parameters) {\n    _classCallCheck(this, UrlSegment);\n\n    this.path = path;\n    this.parameters = parameters;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(UrlSegment, [{\n    key: \"parameterMap\",\n    get: function get() {\n      if (!this._parameterMap) {\n        this._parameterMap = convertToParamMap(this.parameters);\n      }\n\n      return this._parameterMap;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return serializePath(this);\n    }\n  }]);\n\n  return UrlSegment;\n}();\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\n\n\nfunction equalSegments(as, bs) {\n  return equalPath(as, bs) && as.every(function (a, i) {\n    return shallowEqual(a.parameters, bs[i].parameters);\n  });\n}\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\n\n\nfunction equalPath(as, bs) {\n  if (as.length !== bs.length) return false;\n  return as.every(function (a, i) {\n    return a.path === bs[i].path;\n  });\n}\n/**\n * @template T\n * @param {?} segment\n * @param {?} fn\n * @return {?}\n */\n\n\nfunction mapChildrenIntoArray(segment, fn) {\n  /** @type {?} */\n  var res = [];\n  forEach(segment.children, function (child, childOutlet) {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  forEach(segment.children, function (child, childOutlet) {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n/**\n * \\@description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n *\n * @abstract\n */\n\n\nvar UrlSerializer = /*#__PURE__*/_createClass(function UrlSerializer() {\n  _classCallCheck(this, UrlSerializer);\n});\n/**\n * \\@description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n *\n */\n\n\nvar DefaultUrlSerializer = /*#__PURE__*/function () {\n  function DefaultUrlSerializer() {\n    _classCallCheck(this, DefaultUrlSerializer);\n  }\n\n  _createClass(DefaultUrlSerializer, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses a url into a `UrlTree`\n     * @param {?} url\n     * @return {?}\n     */\n    function parse(url) {\n      /** @type {?} */\n      var p = new UrlParser(url);\n      return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n    }\n    /**\n     * Converts a `UrlTree` into a url\n     * @param {?} tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize(tree) {\n      /** @type {?} */\n      var segment = \"/\".concat(serializeSegment(tree.root, true));\n      /** @type {?} */\n\n      var query = serializeQueryParams(tree.queryParams);\n      /** @type {?} */\n\n      var fragment = typeof tree.fragment === \"string\" ? \"#\".concat(encodeUriFragment(\n      /** @type {?} */\n      tree.fragment)) : '';\n      return \"\".concat(segment).concat(query).concat(fragment);\n    }\n  }]);\n\n  return DefaultUrlSerializer;\n}();\n/** @type {?} */\n\n\nvar DEFAULT_SERIALIZER = /*#__PURE__*/new DefaultUrlSerializer();\n/**\n * @param {?} segment\n * @return {?}\n */\n\nfunction serializePaths(segment) {\n  return segment.segments.map(function (p) {\n    return serializePath(p);\n  }).join('/');\n}\n/**\n * @param {?} segment\n * @param {?} root\n * @return {?}\n */\n\n\nfunction serializeSegment(segment, root) {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    /** @type {?} */\n    var primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';\n    /** @type {?} */\n\n    var children = [];\n    forEach(segment.children, function (v, k) {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(\"\".concat(k, \":\").concat(serializeSegment(v, false)));\n      }\n    });\n    return children.length > 0 ? \"\".concat(primary, \"(\").concat(children.join('//'), \")\") : primary;\n  } else {\n    /** @type {?} */\n    var _children = mapChildrenIntoArray(segment, function (v, k) {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [\"\".concat(k, \":\").concat(serializeSegment(v, false))];\n    });\n\n    return \"\".concat(serializePaths(segment), \"/(\").concat(_children.join('//'), \")\");\n  }\n}\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriString(s) {\n  return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');\n}\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriQuery(s) {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriFragment(s) {\n  return encodeURI(s);\n}\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriSegment(s) {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction decode(s) {\n  return decodeURIComponent(s);\n}\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction decodeQuery(s) {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n/**\n * @param {?} path\n * @return {?}\n */\n\n\nfunction serializePath(path) {\n  return \"\".concat(encodeUriSegment(path.path)).concat(serializeMatrixParams(path.parameters));\n}\n/**\n * @param {?} params\n * @return {?}\n */\n\n\nfunction serializeMatrixParams(params) {\n  return Object.keys(params).map(function (key) {\n    return \";\".concat(encodeUriSegment(key), \"=\").concat(encodeUriSegment(params[key]));\n  }).join('');\n}\n/**\n * @param {?} params\n * @return {?}\n */\n\n\nfunction serializeQueryParams(params) {\n  /** @type {?} */\n  var strParams = Object.keys(params).map(function (name) {\n    /** @type {?} */\n    var value = params[name];\n    return Array.isArray(value) ? value.map(function (v) {\n      return \"\".concat(encodeUriQuery(name), \"=\").concat(encodeUriQuery(v));\n    }).join('&') : \"\".concat(encodeUriQuery(name), \"=\").concat(encodeUriQuery(value));\n  });\n  return strParams.length ? \"?\".concat(strParams.join(\"&\")) : '';\n}\n/** @type {?} */\n\n\nvar SEGMENT_RE = /^[^\\/()?;=#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\n\nfunction matchSegments(str) {\n  /** @type {?} */\n  var match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n/** @type {?} */\n\n\nvar QUERY_PARAM_RE = /^[^=?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\n\nfunction matchQueryParams(str) {\n  /** @type {?} */\n  var match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n/** @type {?} */\n\n\nvar QUERY_PARAM_VALUE_RE = /^[^?&#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\n\nfunction matchUrlQueryParamValue(str) {\n  /** @type {?} */\n  var match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nvar UrlParser = /*#__PURE__*/function () {\n  /**\n   * @param {?} url\n   */\n  function UrlParser(url) {\n    _classCallCheck(this, UrlParser);\n\n    this.url = url;\n    this.remaining = url;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(UrlParser, [{\n    key: \"parseRootSegment\",\n    value: function parseRootSegment() {\n      this.consumeOptional('/');\n\n      if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n        return new UrlSegmentGroup([], {});\n      } // The root segment group never has segments\n\n\n      return new UrlSegmentGroup([], this.parseChildren());\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseQueryParams\",\n    value: function parseQueryParams() {\n      /** @type {?} */\n      var params = {};\n\n      if (this.consumeOptional('?')) {\n        do {\n          this.parseQueryParam(params);\n        } while (this.consumeOptional('&'));\n      }\n\n      return params;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseFragment\",\n    value: function parseFragment() {\n      return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseChildren\",\n    value: function parseChildren() {\n      if (this.remaining === '') {\n        return {};\n      }\n\n      this.consumeOptional('/');\n      /** @type {?} */\n\n      var segments = [];\n\n      if (!this.peekStartsWith('(')) {\n        segments.push(this.parseSegment());\n      }\n\n      while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n        this.capture('/');\n        segments.push(this.parseSegment());\n      }\n      /** @type {?} */\n\n\n      var children = {};\n\n      if (this.peekStartsWith('/(')) {\n        this.capture('/');\n        children = this.parseParens(true);\n      }\n      /** @type {?} */\n\n\n      var res = {};\n\n      if (this.peekStartsWith('(')) {\n        res = this.parseParens(false);\n      }\n\n      if (segments.length > 0 || Object.keys(children).length > 0) {\n        res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n      }\n\n      return res;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseSegment\",\n    value: function parseSegment() {\n      /** @type {?} */\n      var path = matchSegments(this.remaining);\n\n      if (path === '' && this.peekStartsWith(';')) {\n        throw new Error(\"Empty path url segment cannot have parameters: '\".concat(this.remaining, \"'.\"));\n      }\n\n      this.capture(path);\n      return new UrlSegment(decode(path), this.parseMatrixParams());\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseMatrixParams\",\n    value: function parseMatrixParams() {\n      /** @type {?} */\n      var params = {};\n\n      while (this.consumeOptional(';')) {\n        this.parseParam(params);\n      }\n\n      return params;\n    }\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseParam\",\n    value: function parseParam(params) {\n      /** @type {?} */\n      var key = matchSegments(this.remaining);\n\n      if (!key) {\n        return;\n      }\n\n      this.capture(key);\n      /** @type {?} */\n\n      var value = '';\n\n      if (this.consumeOptional('=')) {\n        /** @type {?} */\n        var valueMatch = matchSegments(this.remaining);\n\n        if (valueMatch) {\n          value = valueMatch;\n          this.capture(value);\n        }\n      }\n\n      params[decode(key)] = decode(value);\n    }\n    /**\n     * @param {?} params\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseQueryParam\",\n    value: function parseQueryParam(params) {\n      /** @type {?} */\n      var key = matchQueryParams(this.remaining);\n\n      if (!key) {\n        return;\n      }\n\n      this.capture(key);\n      /** @type {?} */\n\n      var value = '';\n\n      if (this.consumeOptional('=')) {\n        /** @type {?} */\n        var valueMatch = matchUrlQueryParamValue(this.remaining);\n\n        if (valueMatch) {\n          value = valueMatch;\n          this.capture(value);\n        }\n      }\n      /** @type {?} */\n\n\n      var decodedKey = decodeQuery(key);\n      /** @type {?} */\n\n      var decodedVal = decodeQuery(value);\n\n      if (params.hasOwnProperty(decodedKey)) {\n        /** @type {?} */\n        var currentVal = params[decodedKey];\n\n        if (!Array.isArray(currentVal)) {\n          currentVal = [currentVal];\n          params[decodedKey] = currentVal;\n        }\n\n        currentVal.push(decodedVal);\n      } else {\n        // Create a new value\n        params[decodedKey] = decodedVal;\n      }\n    }\n    /**\n     * @param {?} allowPrimary\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseParens\",\n    value: function parseParens(allowPrimary) {\n      /** @type {?} */\n      var segments = {};\n      this.capture('(');\n\n      while (!this.consumeOptional(')') && this.remaining.length > 0) {\n        /** @type {?} */\n        var path = matchSegments(this.remaining);\n        /** @type {?} */\n\n        var next = this.remaining[path.length]; // if is is not one of these characters, then the segment was unescaped\n        // or the group was not closed\n\n        if (next !== '/' && next !== ')' && next !== ';') {\n          throw new Error(\"Cannot parse url '\".concat(this.url, \"'\"));\n        }\n        /** @type {?} */\n\n\n        var outletName =\n        /** @type {?} */\n        undefined;\n\n        if (path.indexOf(':') > -1) {\n          outletName = path.substr(0, path.indexOf(':'));\n          this.capture(outletName);\n          this.capture(':');\n        } else if (allowPrimary) {\n          outletName = PRIMARY_OUTLET;\n        }\n        /** @type {?} */\n\n\n        var children = this.parseChildren();\n        segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);\n        this.consumeOptional('//');\n      }\n\n      return segments;\n    }\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n\n  }, {\n    key: \"peekStartsWith\",\n    value: function peekStartsWith(str) {\n      return this.remaining.startsWith(str);\n    }\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n\n  }, {\n    key: \"consumeOptional\",\n    value: function consumeOptional(str) {\n      if (this.peekStartsWith(str)) {\n        this.remaining = this.remaining.substring(str.length);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n\n  }, {\n    key: \"capture\",\n    value: function capture(str) {\n      if (!this.consumeOptional(str)) {\n        throw new Error(\"Expected \\\"\".concat(str, \"\\\".\"));\n      }\n    }\n  }]);\n\n  return UrlParser;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nvar NoMatch = /*#__PURE__*/_createClass(\n/**\n * @param {?=} segmentGroup\n */\nfunction NoMatch(segmentGroup) {\n  _classCallCheck(this, NoMatch);\n\n  this.segmentGroup = segmentGroup || null;\n});\n\nvar AbsoluteRedirect = /*#__PURE__*/_createClass(\n/**\n * @param {?} urlTree\n */\nfunction AbsoluteRedirect(urlTree) {\n  _classCallCheck(this, AbsoluteRedirect);\n\n  this.urlTree = urlTree;\n});\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\n\n\nfunction noMatch(segmentGroup) {\n  return new Observable(function (obs) {\n    return obs.error(new NoMatch(segmentGroup));\n  });\n}\n/**\n * @param {?} newTree\n * @return {?}\n */\n\n\nfunction absoluteRedirect(newTree) {\n  return new Observable(function (obs) {\n    return obs.error(new AbsoluteRedirect(newTree));\n  });\n}\n/**\n * @param {?} redirectTo\n * @return {?}\n */\n\n\nfunction namedOutletsRedirect(redirectTo) {\n  return new Observable(function (obs) {\n    return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\".concat(redirectTo, \"'\")));\n  });\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction canLoadFails(route) {\n  return new Observable(function (obs) {\n    return obs.error(navigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\".concat(route.path, \"'\\\" returned false\")));\n  });\n}\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n * @param {?} moduleInjector\n * @param {?} configLoader\n * @param {?} urlSerializer\n * @param {?} urlTree\n * @param {?} config\n * @return {?}\n */\n\n\nfunction applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n  return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();\n}\n\nvar ApplyRedirects = /*#__PURE__*/function () {\n  /**\n   * @param {?} moduleInjector\n   * @param {?} configLoader\n   * @param {?} urlSerializer\n   * @param {?} urlTree\n   * @param {?} config\n   */\n  function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n    _classCallCheck(this, ApplyRedirects);\n\n    this.configLoader = configLoader;\n    this.urlSerializer = urlSerializer;\n    this.urlTree = urlTree;\n    this.config = config;\n    this.allowRedirects = true;\n    this.ngModule = moduleInjector.get(NgModuleRef);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ApplyRedirects, [{\n    key: \"apply\",\n    value: function apply() {\n      var _this11 = this;\n\n      /** @type {?} */\n      var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n      /** @type {?} */\n\n      var urlTrees$ = expanded$.pipe(map(function (rootSegmentGroup) {\n        return _this11.createUrlTree(rootSegmentGroup, _this11.urlTree.queryParams,\n        /** @type {?} */\n        _this11.urlTree.fragment);\n      }));\n      return urlTrees$.pipe(catchError(function (e) {\n        if (e instanceof AbsoluteRedirect) {\n          // after an absolute redirect we do not apply any more redirects!\n          _this11.allowRedirects = false; // we need to run matching, so we can fetch all lazy-loaded modules\n\n          return _this11.match(e.urlTree);\n        }\n\n        if (e instanceof NoMatch) {\n          throw _this11.noMatchError(e);\n        }\n\n        throw e;\n      }));\n    }\n    /**\n     * @param {?} tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"match\",\n    value: function match(tree) {\n      var _this12 = this;\n\n      /** @type {?} */\n      var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\n      /** @type {?} */\n\n      var mapped$ = expanded$.pipe(map(function (rootSegmentGroup) {\n        return _this12.createUrlTree(rootSegmentGroup, tree.queryParams,\n        /** @type {?} */\n        tree.fragment);\n      }));\n      return mapped$.pipe(catchError(function (e) {\n        if (e instanceof NoMatch) {\n          throw _this12.noMatchError(e);\n        }\n\n        throw e;\n      }));\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n\n  }, {\n    key: \"noMatchError\",\n    value: function noMatchError(e) {\n      return new Error(\"Cannot match any routes. URL Segment: '\".concat(e.segmentGroup, \"'\"));\n    }\n    /**\n     * @param {?} rootCandidate\n     * @param {?} queryParams\n     * @param {?} fragment\n     * @return {?}\n     */\n\n  }, {\n    key: \"createUrlTree\",\n    value: function createUrlTree(rootCandidate, queryParams, fragment) {\n      /** @type {?} */\n      var root = rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], _defineProperty({}, PRIMARY_OUTLET, rootCandidate)) : rootCandidate;\n      return new UrlTree(root, queryParams, fragment);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegmentGroup\",\n    value: function expandSegmentGroup(ngModule, routes, segmentGroup, outlet) {\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return this.expandChildren(ngModule, routes, segmentGroup).pipe(map(function (children) {\n          return new UrlSegmentGroup([], children);\n        }));\n      }\n\n      return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandChildren\",\n    value: function expandChildren(ngModule, routes, segmentGroup) {\n      var _this13 = this;\n\n      return waitForMap(segmentGroup.children, function (childOutlet, child) {\n        return _this13.expandSegmentGroup(ngModule, routes, child, childOutlet);\n      });\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} segments\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegment\",\n    value: function expandSegment(ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {\n      var _this14 = this;\n\n      return of.apply(void 0, _toConsumableArray(routes)).pipe(map(function (r) {\n        /** @type {?} */\n        var expanded$ = _this14.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n\n        return expanded$.pipe(catchError(function (e) {\n          if (e instanceof NoMatch) {\n            // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -\n            // talk to Jason\n            return (\n              /** @type {?} */\n              of(null)\n            );\n          }\n\n          throw e;\n        }));\n      }), concatAll(), first(function (s) {\n        return !!s;\n      }), catchError(function (e, _) {\n        if (e instanceof EmptyError || e.name === 'EmptyError') {\n          if (_this14.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return of(new UrlSegmentGroup([], {}));\n          }\n\n          throw new NoMatch(segmentGroup);\n        }\n\n        throw e;\n      }));\n    }\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"noLeftoversInUrl\",\n    value: function noLeftoversInUrl(segmentGroup, segments, outlet) {\n      return segments.length === 0 && !segmentGroup.children[outlet];\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} paths\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegmentAgainstRoute\",\n    value: function expandSegmentAgainstRoute(ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n      if (getOutlet(route) !== outlet) {\n        return noMatch(segmentGroup);\n      }\n\n      if (route.redirectTo === undefined) {\n        return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\n      }\n\n      if (allowRedirects && this.allowRedirects) {\n        return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);\n      }\n\n      return noMatch(segmentGroup);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegmentAgainstRouteUsingRedirect\",\n    value: function expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {\n      if (route.path === '**') {\n        return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);\n      }\n\n      return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandWildCardWithParamsAgainstRouteUsingRedirect\",\n    value: function expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet) {\n      var _this15 = this;\n\n      /** @type {?} */\n      var newTree = this.applyRedirectCommands([],\n      /** @type {?} */\n      route.redirectTo, {});\n\n      if (\n      /** @type {?} */\n      route.redirectTo.startsWith('/')) {\n        return absoluteRedirect(newTree);\n      }\n\n      return this.lineralizeSegments(route, newTree).pipe(mergeMap(function (newSegments) {\n        /** @type {?} */\n        var group = new UrlSegmentGroup(newSegments, {});\n        return _this15.expandSegment(ngModule, group, routes, newSegments, outlet, false);\n      }));\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandRegularSegmentAgainstRouteUsingRedirect\",\n    value: function expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {\n      var _this16 = this;\n\n      var _match = match(segmentGroup, route, segments),\n          matched = _match.matched,\n          consumedSegments = _match.consumedSegments,\n          lastChild = _match.lastChild,\n          positionalParamSegments = _match.positionalParamSegments;\n\n      if (!matched) return noMatch(segmentGroup);\n      /** @type {?} */\n\n      var newTree = this.applyRedirectCommands(consumedSegments,\n      /** @type {?} */\n      route.redirectTo,\n      /** @type {?} */\n      positionalParamSegments);\n\n      if (\n      /** @type {?} */\n      route.redirectTo.startsWith('/')) {\n        return absoluteRedirect(newTree);\n      }\n\n      return this.lineralizeSegments(route, newTree).pipe(mergeMap(function (newSegments) {\n        return _this16.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n      }));\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} rawSegmentGroup\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n\n  }, {\n    key: \"matchSegmentAgainstRoute\",\n    value: function matchSegmentAgainstRoute(ngModule, rawSegmentGroup, route, segments) {\n      var _this17 = this;\n\n      if (route.path === '**') {\n        if (route.loadChildren) {\n          return this.configLoader.load(ngModule.injector, route).pipe(map(function (cfg) {\n            route._loadedConfig = cfg;\n            return new UrlSegmentGroup(segments, {});\n          }));\n        }\n\n        return of(new UrlSegmentGroup(segments, {}));\n      }\n\n      var _match2 = match(rawSegmentGroup, route, segments),\n          matched = _match2.matched,\n          consumedSegments = _match2.consumedSegments,\n          lastChild = _match2.lastChild;\n\n      if (!matched) return noMatch(rawSegmentGroup);\n      /** @type {?} */\n\n      var rawSlicedSegments = segments.slice(lastChild);\n      /** @type {?} */\n\n      var childConfig$ = this.getChildConfig(ngModule, route);\n      return childConfig$.pipe(mergeMap(function (routerConfig) {\n        /** @type {?} */\n        var childModule = routerConfig.module;\n        /** @type {?} */\n\n        var childConfig = routerConfig.routes;\n\n        var _split = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig),\n            segmentGroup = _split.segmentGroup,\n            slicedSegments = _split.slicedSegments;\n\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n          /** @type {?} */\n          var _expanded$ = _this17.expandChildren(childModule, childConfig, segmentGroup);\n\n          return _expanded$.pipe(map(function (children) {\n            return new UrlSegmentGroup(consumedSegments, children);\n          }));\n        }\n\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n          return of(new UrlSegmentGroup(consumedSegments, {}));\n        }\n        /** @type {?} */\n\n\n        var expanded$ = _this17.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n\n        return expanded$.pipe(map(function (cs) {\n          return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);\n        }));\n      }));\n    }\n    /**\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n\n  }, {\n    key: \"getChildConfig\",\n    value: function getChildConfig(ngModule, route) {\n      var _this18 = this;\n\n      if (route.children) {\n        // The children belong to the same module\n        return of(new LoadedRouterConfig(route.children, ngModule));\n      }\n\n      if (route.loadChildren) {\n        // lazy children belong to the loaded module\n        if (route._loadedConfig !== undefined) {\n          return of(route._loadedConfig);\n        }\n\n        return runCanLoadGuard(ngModule.injector, route).pipe(mergeMap(function (shouldLoad) {\n          if (shouldLoad) {\n            return _this18.configLoader.load(ngModule.injector, route).pipe(map(function (cfg) {\n              route._loadedConfig = cfg;\n              return cfg;\n            }));\n          }\n\n          return canLoadFails(route);\n        }));\n      }\n\n      return of(new LoadedRouterConfig([], ngModule));\n    }\n    /**\n     * @param {?} route\n     * @param {?} urlTree\n     * @return {?}\n     */\n\n  }, {\n    key: \"lineralizeSegments\",\n    value: function lineralizeSegments(route, urlTree) {\n      /** @type {?} */\n      var res = [];\n      /** @type {?} */\n\n      var c = urlTree.root;\n\n      while (true) {\n        res = res.concat(c.segments);\n\n        if (c.numberOfChildren === 0) {\n          return of(res);\n        }\n\n        if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n          return namedOutletsRedirect(\n          /** @type {?} */\n          route.redirectTo);\n        }\n\n        c = c.children[PRIMARY_OUTLET];\n      }\n    }\n    /**\n     * @param {?} segments\n     * @param {?} redirectTo\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyRedirectCommands\",\n    value: function applyRedirectCommands(segments, redirectTo, posParams) {\n      return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    }\n    /**\n     * @param {?} redirectTo\n     * @param {?} urlTree\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyRedirectCreatreUrlTree\",\n    value: function applyRedirectCreatreUrlTree(redirectTo, urlTree, segments, posParams) {\n      /** @type {?} */\n      var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n      return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n    }\n    /**\n     * @param {?} redirectToParams\n     * @param {?} actualParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"createQueryParams\",\n    value: function createQueryParams(redirectToParams, actualParams) {\n      /** @type {?} */\n      var res = {};\n      forEach(redirectToParams, function (v, k) {\n        /** @type {?} */\n        var copySourceValue = typeof v === 'string' && v.startsWith(':');\n\n        if (copySourceValue) {\n          /** @type {?} */\n          var sourceName = v.substring(1);\n          res[k] = actualParams[sourceName];\n        } else {\n          res[k] = v;\n        }\n      });\n      return res;\n    }\n    /**\n     * @param {?} redirectTo\n     * @param {?} group\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"createSegmentGroup\",\n    value: function createSegmentGroup(redirectTo, group, segments, posParams) {\n      var _this19 = this;\n\n      /** @type {?} */\n      var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n      /** @type {?} */\n\n      var children = {};\n      forEach(group.children, function (child, name) {\n        children[name] = _this19.createSegmentGroup(redirectTo, child, segments, posParams);\n      });\n      return new UrlSegmentGroup(updatedSegments, children);\n    }\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToSegments\n     * @param {?} actualSegments\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"createSegments\",\n    value: function createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n      var _this20 = this;\n\n      return redirectToSegments.map(function (s) {\n        return s.path.startsWith(':') ? _this20.findPosParam(redirectTo, s, posParams) : _this20.findOrReturn(s, actualSegments);\n      });\n    }\n    /**\n     * @param {?} redirectTo\n     * @param {?} redirectToUrlSegment\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"findPosParam\",\n    value: function findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n      /** @type {?} */\n      var pos = posParams[redirectToUrlSegment.path.substring(1)];\n      if (!pos) throw new Error(\"Cannot redirect to '\".concat(redirectTo, \"'. Cannot find '\").concat(redirectToUrlSegment.path, \"'.\"));\n      return pos;\n    }\n    /**\n     * @param {?} redirectToUrlSegment\n     * @param {?} actualSegments\n     * @return {?}\n     */\n\n  }, {\n    key: \"findOrReturn\",\n    value: function findOrReturn(redirectToUrlSegment, actualSegments) {\n      /** @type {?} */\n      var idx = 0;\n\n      var _iterator = _createForOfIteratorHelper(actualSegments),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var s = _step.value;\n\n          if (s.path === redirectToUrlSegment.path) {\n            actualSegments.splice(idx);\n            return s;\n          }\n\n          idx++;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return redirectToUrlSegment;\n    }\n  }]);\n\n  return ApplyRedirects;\n}();\n/**\n * @param {?} moduleInjector\n * @param {?} route\n * @return {?}\n */\n\n\nfunction runCanLoadGuard(moduleInjector, route) {\n  /** @type {?} */\n  var canLoad = route.canLoad;\n  if (!canLoad || canLoad.length === 0) return of(true);\n  /** @type {?} */\n\n  var obs = from(canLoad).pipe(map(function (injectionToken) {\n    /** @type {?} */\n    var guard = moduleInjector.get(injectionToken);\n    return wrapIntoObservable(guard.canLoad ? guard.canLoad(route) : guard(route));\n  }));\n  return andObservables(obs);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\n\n\nfunction match(segmentGroup, route, segments) {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {\n        matched: false,\n        consumedSegments: [],\n        lastChild: 0,\n        positionalParamSegments: {}\n      };\n    }\n\n    return {\n      matched: true,\n      consumedSegments: [],\n      lastChild: 0,\n      positionalParamSegments: {}\n    };\n  }\n  /** @type {?} */\n\n\n  var matcher = route.matcher || defaultUrlMatcher;\n  /** @type {?} */\n\n  var res = matcher(segments, segmentGroup, route);\n\n  if (!res) {\n    return {\n      matched: false,\n      consumedSegments:\n      /** @type {?} */\n      [],\n      lastChild: 0,\n      positionalParamSegments: {}\n    };\n  }\n\n  return {\n    matched: true,\n    consumedSegments:\n    /** @type {?} */\n    res.consumed,\n    lastChild:\n    /** @type {?} */\n    res.consumed.length,\n    positionalParamSegments:\n    /** @type {?} */\n    res.posParams\n  };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @return {?}\n */\n\n\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n  if (slicedSegments.length > 0 && containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    /** @type {?} */\n    var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {\n      segmentGroup: mergeTrivialChildren(s),\n      slicedSegments: []\n    };\n  }\n\n  if (slicedSegments.length === 0 && containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n    /** @type {?} */\n    var _s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\n    return {\n      segmentGroup: mergeTrivialChildren(_s),\n      slicedSegments: slicedSegments\n    };\n  }\n\n  return {\n    segmentGroup: segmentGroup,\n    slicedSegments: slicedSegments\n  };\n}\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction mergeTrivialChildren(s) {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    /** @type {?} */\n    var c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @return {?}\n */\n\n\nfunction addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n  /** @type {?} */\n  var res = {};\n\n  var _iterator2 = _createForOfIteratorHelper(routes),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var r = _step2.value;\n\n      if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n        res[getOutlet(r)] = new UrlSegmentGroup([], {});\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return Object.assign({}, children, res);\n}\n/**\n * @param {?} routes\n * @param {?} primarySegmentGroup\n * @return {?}\n */\n\n\nfunction createChildrenForEmptySegments(routes, primarySegmentGroup) {\n  /** @type {?} */\n  var res = {};\n  res[PRIMARY_OUTLET] = primarySegmentGroup;\n\n  var _iterator3 = _createForOfIteratorHelper(routes),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var r = _step3.value;\n\n      if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n        res[getOutlet(r)] = new UrlSegmentGroup([], {});\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {\n  return routes.some(function (r) {\n    return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET;\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathRedirects(segmentGroup, segments, routes) {\n  return routes.some(function (r) {\n    return isEmptyPathRedirect(segmentGroup, segments, r);\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} r\n * @return {?}\n */\n\n\nfunction isEmptyPathRedirect(segmentGroup, segments, r) {\n  if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '' && r.redirectTo !== undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getOutlet(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @template T\n */\n\n\nvar Tree = /*#__PURE__*/function () {\n  /**\n   * @param {?} root\n   */\n  function Tree(root) {\n    _classCallCheck(this, Tree);\n\n    this._root = root;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Tree, [{\n    key: \"root\",\n    get: function get() {\n      return this._root.value;\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"parent\",\n    value: function parent(t) {\n      /** @type {?} */\n      var p = this.pathFromRoot(t);\n      return p.length > 1 ? p[p.length - 2] : null;\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"children\",\n    value: function children(t) {\n      /** @type {?} */\n      var n = findNode(t, this._root);\n      return n ? n.children.map(function (t) {\n        return t.value;\n      }) : [];\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"firstChild\",\n    value: function firstChild(t) {\n      /** @type {?} */\n      var n = findNode(t, this._root);\n      return n && n.children.length > 0 ? n.children[0].value : null;\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"siblings\",\n    value: function siblings(t) {\n      /** @type {?} */\n      var p = findPath(t, this._root);\n      if (p.length < 2) return [];\n      /** @type {?} */\n\n      var c = p[p.length - 2].children.map(function (c) {\n        return c.value;\n      });\n      return c.filter(function (cc) {\n        return cc !== t;\n      });\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    value: function pathFromRoot(t) {\n      return findPath(t, this._root).map(function (s) {\n        return s.value;\n      });\n    }\n  }]);\n\n  return Tree;\n}();\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\n\n\nfunction findNode(value, node) {\n  if (value === node.value) return node;\n\n  var _iterator4 = _createForOfIteratorHelper(node.children),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var child = _step4.value;\n\n      /** @type {?} */\n      var _node = findNode(value, child);\n\n      if (_node) return _node;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return null;\n}\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\n\n\nfunction findPath(value, node) {\n  if (value === node.value) return [node];\n\n  var _iterator5 = _createForOfIteratorHelper(node.children),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var child = _step5.value;\n\n      /** @type {?} */\n      var path = findPath(value, child);\n\n      if (path.length) {\n        path.unshift(node);\n        return path;\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return [];\n}\n/**\n * @template T\n */\n\n\nvar TreeNode = /*#__PURE__*/function () {\n  /**\n   * @param {?} value\n   * @param {?} children\n   */\n  function TreeNode(value, children) {\n    _classCallCheck(this, TreeNode);\n\n    this.value = value;\n    this.children = children;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(TreeNode, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"TreeNode(\".concat(this.value, \")\");\n    }\n  }]);\n\n  return TreeNode;\n}();\n/**\n * @template T\n * @param {?} node\n * @return {?}\n */\n\n\nfunction nodeChildrenAsMap(node) {\n  /** @type {?} */\n  var map$$1 = {};\n\n  if (node) {\n    node.children.forEach(function (child) {\n      return map$$1[child.value.outlet] = child;\n    });\n  }\n\n  return map$$1;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Represents the state of the router.\n *\n * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\n * segments, the extracted parameters, and the resolved data.\n *\n * \\@usageNotes\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * See `ActivatedRoute` for more information.\n *\n *\n */\n\n\nvar RouterState = /*#__PURE__*/function (_Tree) {\n  _inherits(RouterState, _Tree);\n\n  var _super10 = _createSuper(RouterState);\n\n  /**\n   * \\@internal\n   * @param {?} root\n   * @param {?} snapshot\n   */\n  function RouterState(root, snapshot) {\n    var _this21;\n\n    _classCallCheck(this, RouterState);\n\n    _this21 = _super10.call(this, root);\n    _this21.snapshot = snapshot;\n    setRouterState(\n    /** @type {?} */\n    _assertThisInitialized(_this21), root);\n    return _this21;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterState, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.snapshot.toString();\n    }\n  }]);\n\n  return RouterState;\n}(Tree);\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\n\n\nfunction createEmptyState(urlTree, rootComponent) {\n  /** @type {?} */\n  var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n  /** @type {?} */\n\n  var emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  /** @type {?} */\n\n  var emptyParams = new BehaviorSubject({});\n  /** @type {?} */\n\n  var emptyData = new BehaviorSubject({});\n  /** @type {?} */\n\n  var emptyQueryParams = new BehaviorSubject({});\n  /** @type {?} */\n\n  var fragment = new BehaviorSubject('');\n  /** @type {?} */\n\n  var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode(activated, []), snapshot);\n}\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\n\n\nfunction createEmptyStateSnapshot(urlTree, rootComponent) {\n  /** @type {?} */\n  var emptyParams = {};\n  /** @type {?} */\n\n  var emptyData = {};\n  /** @type {?} */\n\n  var emptyQueryParams = {};\n  /** @type {?} */\n\n  var fragment = '';\n  /** @type {?} */\n\n  var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n  return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\n * \\@description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet.  An `ActivatedRoute` can also be used to traverse the router state tree.\n *\n * ```\n * \\@Component({...})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: Observable<string> = route.params.map(p => p.id);\n *     const url: Observable<string> = route.url.map(segments => segments.join(''));\n *     // route.data includes both `data` and `resolve`\n *     const user = route.data.map(d => d.user);\n *   }\n * }\n * ```\n *\n *\n */\n\n\nvar ActivatedRoute = /*#__PURE__*/function () {\n  /**\n   * \\@internal\n   * @param {?} url\n   * @param {?} params\n   * @param {?} queryParams\n   * @param {?} fragment\n   * @param {?} data\n   * @param {?} outlet\n   * @param {?} component\n   * @param {?} futureSnapshot\n   */\n  function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {\n    _classCallCheck(this, ActivatedRoute);\n\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this._futureSnapshot = futureSnapshot;\n  }\n  /**\n   * The configuration used to match this route\n   * @return {?}\n   */\n\n\n  _createClass(ActivatedRoute, [{\n    key: \"routeConfig\",\n    get: function get() {\n      return this._futureSnapshot.routeConfig;\n    }\n    /**\n     * The root of the router state\n     * @return {?}\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this._routerState.root;\n    }\n    /**\n     * The parent of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._routerState.parent(this);\n    }\n    /**\n     * The first child of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this._routerState.firstChild(this);\n    }\n    /**\n     * The children of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._routerState.children(this);\n    }\n    /**\n     * The path from the root of the router state tree to this route\n     * @return {?}\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    get: function get() {\n      return this._routerState.pathFromRoot(this);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"paramMap\",\n    get: function get() {\n      if (!this._paramMap) {\n        this._paramMap = this.params.pipe(map(function (p) {\n          return convertToParamMap(p);\n        }));\n      }\n\n      return this._paramMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = this.queryParams.pipe(map(function (p) {\n          return convertToParamMap(p);\n        }));\n      }\n\n      return this._queryParamMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.snapshot ? this.snapshot.toString() : \"Future(\".concat(this._futureSnapshot, \")\");\n    }\n  }]);\n\n  return ActivatedRoute;\n}();\n/**\n * Returns the inherited params, data, and resolve for a given route.\n * By default, this only inherits values up to the nearest path-less or component-less route.\n * \\@internal\n * @param {?} route\n * @param {?=} paramsInheritanceStrategy\n * @return {?}\n */\n\n\nfunction inheritedParamsDataResolve(route) {\n  var paramsInheritanceStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'emptyOnly';\n\n  /** @type {?} */\n  var pathFromRoot = route.pathFromRoot;\n  /** @type {?} */\n\n  var inheritingStartingFrom = 0;\n\n  if (paramsInheritanceStrategy !== 'always') {\n    inheritingStartingFrom = pathFromRoot.length - 1;\n\n    while (inheritingStartingFrom >= 1) {\n      /** @type {?} */\n      var current = pathFromRoot[inheritingStartingFrom];\n      /** @type {?} */\n\n      var parent = pathFromRoot[inheritingStartingFrom - 1]; // current route is an empty path => inherits its parent's params and data\n\n      if (current.routeConfig && current.routeConfig.path === '') {\n        inheritingStartingFrom--; // parent is componentless => current route should inherit its params and data\n      } else if (!parent.component) {\n        inheritingStartingFrom--;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));\n}\n/**\n * \\@internal\n * @param {?} pathFromRoot\n * @return {?}\n */\n\n\nfunction flattenInherited(pathFromRoot) {\n  return pathFromRoot.reduce(function (res, curr) {\n    /** @type {?} */\n    var params = Object.assign({}, res.params, curr.params);\n    /** @type {?} */\n\n    var data = Object.assign({}, res.data, curr.data);\n    /** @type {?} */\n\n    var resolve = Object.assign({}, res.resolve, curr._resolvedData);\n    return {\n      params: params,\n      data: data,\n      resolve: resolve\n    };\n  },\n  /** @type {?} */\n  {\n    params: {},\n    data: {},\n    resolve: {}\n  });\n}\n/**\n * \\@description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * ```\n * \\@Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n *\n */\n\n\nvar ActivatedRouteSnapshot = /*#__PURE__*/function () {\n  /**\n   * \\@internal\n   * @param {?} url\n   * @param {?} params\n   * @param {?} queryParams\n   * @param {?} fragment\n   * @param {?} data\n   * @param {?} outlet\n   * @param {?} component\n   * @param {?} routeConfig\n   * @param {?} urlSegment\n   * @param {?} lastPathIndex\n   * @param {?} resolve\n   */\n  function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {\n    _classCallCheck(this, ActivatedRouteSnapshot);\n\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this.routeConfig = routeConfig;\n    this._urlSegment = urlSegment;\n    this._lastPathIndex = lastPathIndex;\n    this._resolve = resolve;\n  }\n  /**\n   * The root of the router state\n   * @return {?}\n   */\n\n\n  _createClass(ActivatedRouteSnapshot, [{\n    key: \"root\",\n    get: function get() {\n      return this._routerState.root;\n    }\n    /**\n     * The parent of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._routerState.parent(this);\n    }\n    /**\n     * The first child of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this._routerState.firstChild(this);\n    }\n    /**\n     * The children of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._routerState.children(this);\n    }\n    /**\n     * The path from the root of the router state tree to this route\n     * @return {?}\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    get: function get() {\n      return this._routerState.pathFromRoot(this);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"paramMap\",\n    get: function get() {\n      if (!this._paramMap) {\n        this._paramMap = convertToParamMap(this.params);\n      }\n\n      return this._paramMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = convertToParamMap(this.queryParams);\n      }\n\n      return this._queryParamMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var url = this.url.map(function (segment) {\n        return segment.toString();\n      }).join('/');\n      /** @type {?} */\n\n      var matched = this.routeConfig ? this.routeConfig.path : '';\n      return \"Route(url:'\".concat(url, \"', path:'\").concat(matched, \"')\");\n    }\n  }]);\n\n  return ActivatedRouteSnapshot;\n}();\n/**\n * \\@description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * \\@usageNotes\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n *\n */\n\n\nvar RouterStateSnapshot = /*#__PURE__*/function (_Tree2) {\n  _inherits(RouterStateSnapshot, _Tree2);\n\n  var _super11 = _createSuper(RouterStateSnapshot);\n\n  /**\n   * \\@internal\n   * @param {?} url\n   * @param {?} root\n   */\n  function RouterStateSnapshot(url, root) {\n    var _this22;\n\n    _classCallCheck(this, RouterStateSnapshot);\n\n    _this22 = _super11.call(this, root);\n    _this22.url = url;\n    setRouterState(\n    /** @type {?} */\n    _assertThisInitialized(_this22), root);\n    return _this22;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterStateSnapshot, [{\n    key: \"toString\",\n    value: function toString() {\n      return serializeNode(this._root);\n    }\n  }]);\n\n  return RouterStateSnapshot;\n}(Tree);\n/**\n * @template U, T\n * @param {?} state\n * @param {?} node\n * @return {?}\n */\n\n\nfunction setRouterState(state, node) {\n  node.value._routerState = state;\n  node.children.forEach(function (c) {\n    return setRouterState(state, c);\n  });\n}\n/**\n * @param {?} node\n * @return {?}\n */\n\n\nfunction serializeNode(node) {\n  /** @type {?} */\n  var c = node.children.length > 0 ? \" { \".concat(node.children.map(serializeNode).join(', '), \" } \") : '';\n  return \"\".concat(node.value).concat(c);\n}\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n * @param {?} route\n * @return {?}\n */\n\n\nfunction advanceActivatedRoute(route) {\n  if (route.snapshot) {\n    /** @type {?} */\n    var currentSnapshot = route.snapshot;\n    /** @type {?} */\n\n    var nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      /** @type {?} */\n      route.queryParams.next(nextSnapshot.queryParams);\n    }\n\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      /** @type {?} */\n      route.fragment.next(nextSnapshot.fragment);\n    }\n\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      /** @type {?} */\n      route.params.next(nextSnapshot.params);\n    }\n\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      /** @type {?} */\n      route.url.next(nextSnapshot.url);\n    }\n\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      /** @type {?} */\n      route.data.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot; // this is for resolved data\n\n    /** @type {?} */\n    route.data.next(route._futureSnapshot.data);\n  }\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction equalParamsAndUrlSegments(a, b) {\n  /** @type {?} */\n  var equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  /** @type {?} */\n\n  var parentsMismatch = !a.parent !== !b.parent;\n  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent,\n  /** @type {?} */\n  b.parent));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\n\n\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n  /** @type {?} */\n  var root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?=} prevState\n * @return {?}\n */\n\n\nfunction createNode(routeReuseStrategy, curr, prevState) {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    /** @type {?} */\n    var value = prevState.value;\n    value._futureSnapshot = curr.value;\n    /** @type {?} */\n\n    var children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode(value, children); // retrieve an activated route that is used to be displayed, but is not currently displayed\n  } else {\n    /** @type {?} */\n    var detachedRouteHandle =\n    /** @type {?} */\n    routeReuseStrategy.retrieve(curr.value);\n\n    if (detachedRouteHandle) {\n      /** @type {?} */\n      var _tree = detachedRouteHandle.route;\n      setFutureSnapshotsOfActivatedRoutes(curr, _tree);\n      return _tree;\n    } else {\n      /** @type {?} */\n      var _value = createActivatedRoute(curr.value);\n      /** @type {?} */\n\n\n      var _children2 = curr.children.map(function (c) {\n        return createNode(routeReuseStrategy, c);\n      });\n\n      return new TreeNode(_value, _children2);\n    }\n  }\n}\n/**\n * @param {?} curr\n * @param {?} result\n * @return {?}\n */\n\n\nfunction setFutureSnapshotsOfActivatedRoutes(curr, result) {\n  if (curr.value.routeConfig !== result.value.routeConfig) {\n    throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');\n  }\n\n  if (curr.children.length !== result.children.length) {\n    throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');\n  }\n\n  result.value._futureSnapshot = curr.value;\n\n  for (var i = 0; i < curr.children.length; ++i) {\n    setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\n  }\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\n\n\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n  return curr.children.map(function (child) {\n    var _iterator6 = _createForOfIteratorHelper(prevState.children),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var p = _step6.value;\n\n        if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\n          return createNode(routeReuseStrategy, child, p);\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    return createNode(routeReuseStrategy, child);\n  });\n}\n/**\n * @param {?} c\n * @return {?}\n */\n\n\nfunction createActivatedRoute(c) {\n  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} route\n * @param {?} urlTree\n * @param {?} commands\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\n\n\nfunction _createUrlTree(route, urlTree, commands, queryParams, fragment) {\n  if (commands.length === 0) {\n    return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n  }\n  /** @type {?} */\n\n\n  var nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n  }\n  /** @type {?} */\n\n\n  var startingPosition = findStartingPosition(nav, urlTree, route);\n  /** @type {?} */\n\n  var segmentGroup = startingPosition.processChildren ? updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) : updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n  return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n}\n/**\n * @param {?} command\n * @return {?}\n */\n\n\nfunction isMatrixParams(command) {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\n * @param {?} oldSegmentGroup\n * @param {?} newSegmentGroup\n * @param {?} urlTree\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\n\n\nfunction tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n  /** @type {?} */\n  var qp = {};\n\n  if (queryParams) {\n    forEach(queryParams, function (value, name) {\n      qp[name] = Array.isArray(value) ? value.map(function (v) {\n        return \"\".concat(v);\n      }) : \"\".concat(value);\n    });\n  }\n\n  if (urlTree.root === oldSegmentGroup) {\n    return new UrlTree(newSegmentGroup, qp, fragment);\n  }\n\n  return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);\n}\n/**\n * @param {?} current\n * @param {?} oldSegment\n * @param {?} newSegment\n * @return {?}\n */\n\n\nfunction replaceSegment(current, oldSegment, newSegment) {\n  /** @type {?} */\n  var children = {};\n  forEach(current.children, function (c, outletName) {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nvar Navigation = /*#__PURE__*/function () {\n  /**\n   * @param {?} isAbsolute\n   * @param {?} numberOfDoubleDots\n   * @param {?} commands\n   */\n  function Navigation(isAbsolute, numberOfDoubleDots, commands) {\n    _classCallCheck(this, Navigation);\n\n    this.isAbsolute = isAbsolute;\n    this.numberOfDoubleDots = numberOfDoubleDots;\n    this.commands = commands;\n\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new Error('Root segment cannot have matrix parameters');\n    }\n    /** @type {?} */\n\n\n    var cmdWithOutlet = commands.find(function (c) {\n      return typeof c === 'object' && c != null && c.outlets;\n    });\n\n    if (cmdWithOutlet && cmdWithOutlet !== last$1(commands)) {\n      throw new Error('{outlets:{}} has to be the last command');\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Navigation, [{\n    key: \"toRoot\",\n    value: function toRoot() {\n      return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n    }\n  }]);\n\n  return Navigation;\n}();\n/**\n * Transforms commands to a normalized `Navigation`\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction computeNavigation(commands) {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n  /** @type {?} */\n\n\n  var numberOfDoubleDots = 0;\n  /** @type {?} */\n\n  var isAbsolute = false;\n  /** @type {?} */\n\n  var res = commands.reduce(function (res, cmd, cmdIdx) {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        /** @type {?} */\n        var outlets = {};\n        forEach(cmd.outlets, function (commands, name) {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [].concat(_toConsumableArray(res), [{\n          outlets: outlets\n        }]);\n      }\n\n      if (cmd.segmentPath) {\n        return [].concat(_toConsumableArray(res), [cmd.segmentPath]);\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [].concat(_toConsumableArray(res), [cmd]);\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach(function (urlPart, partIndex) {\n        if (partIndex == 0 && urlPart === '.') ;else if (partIndex == 0 && urlPart === '') {\n          //  '/a'\n          //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          //  '../a'\n          //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n      return res;\n    }\n\n    return [].concat(_toConsumableArray(res), [cmd]);\n  }, []);\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nvar Position = /*#__PURE__*/_createClass(\n/**\n * @param {?} segmentGroup\n * @param {?} processChildren\n * @param {?} index\n */\nfunction Position(segmentGroup, processChildren, index) {\n  _classCallCheck(this, Position);\n\n  this.segmentGroup = segmentGroup;\n  this.processChildren = processChildren;\n  this.index = index;\n});\n/**\n * @param {?} nav\n * @param {?} tree\n * @param {?} route\n * @return {?}\n */\n\n\nfunction findStartingPosition(nav, tree, route) {\n  if (nav.isAbsolute) {\n    return new Position(tree.root, true, 0);\n  }\n\n  if (route.snapshot._lastPathIndex === -1) {\n    return new Position(route.snapshot._urlSegment, true, 0);\n  }\n  /** @type {?} */\n\n\n  var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  /** @type {?} */\n\n  var index = route.snapshot._lastPathIndex + modifier;\n  return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\n}\n/**\n * @param {?} group\n * @param {?} index\n * @param {?} numberOfDoubleDots\n * @return {?}\n */\n\n\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n  /** @type {?} */\n  var g = group;\n  /** @type {?} */\n\n  var ci = index;\n  /** @type {?} */\n\n  var dd = numberOfDoubleDots;\n\n  while (dd > ci) {\n    dd -= ci;\n    g =\n    /** @type {?} */\n    g.parent;\n\n    if (!g) {\n      throw new Error('Invalid number of \\'../\\'');\n    }\n\n    ci = g.segments.length;\n  }\n\n  return new Position(g, false, ci - dd);\n}\n/**\n * @param {?} command\n * @return {?}\n */\n\n\nfunction getPath(command) {\n  if (typeof command === 'object' && command != null && command.outlets) {\n    return command.outlets[PRIMARY_OUTLET];\n  }\n\n  return \"\".concat(command);\n}\n/**\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction getOutlets(commands) {\n  if (!(typeof commands[0] === 'object')) return _defineProperty({}, PRIMARY_OUTLET, commands);\n  if (commands[0].outlets === undefined) return _defineProperty({}, PRIMARY_OUTLET, commands);\n  return commands[0].outlets;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n  if (!segmentGroup) {\n    segmentGroup = new UrlSegmentGroup([], {});\n  }\n\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n  /** @type {?} */\n\n\n  var m = prefixedWith(segmentGroup, startIndex, commands);\n  /** @type {?} */\n\n  var slicedCommands = commands.slice(m.commandIndex);\n\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    /** @type {?} */\n    var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    /** @type {?} */\n    var outlets = getOutlets(commands);\n    /** @type {?} */\n\n    var children = {};\n    forEach(outlets, function (commands, outlet) {\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n    forEach(segmentGroup.children, function (child, childOutlet) {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n  /** @type {?} */\n  var currentCommandIndex = 0;\n  /** @type {?} */\n\n  var currentPathIndex = startIndex;\n  /** @type {?} */\n\n  var noMatch = {\n    match: false,\n    pathIndex: 0,\n    commandIndex: 0\n  };\n\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    /** @type {?} */\n\n    var path = segmentGroup.segments[currentPathIndex];\n    /** @type {?} */\n\n    var curr = getPath(commands[currentCommandIndex]);\n    /** @type {?} */\n\n    var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n\n    currentPathIndex++;\n  }\n\n  return {\n    match: true,\n    pathIndex: currentPathIndex,\n    commandIndex: currentCommandIndex\n  };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n  /** @type {?} */\n  var paths = segmentGroup.segments.slice(0, startIndex);\n  /** @type {?} */\n\n  var i = 0;\n\n  while (i < commands.length) {\n    if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n      /** @type {?} */\n      var children = createNewSegmentChildren(commands[i].outlets);\n      return new UrlSegmentGroup(paths, children);\n    } // if we start with an object literal, we need to reuse the path part from the segment\n\n\n    if (i === 0 && isMatrixParams(commands[0])) {\n      /** @type {?} */\n      var p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, commands[0]));\n      i++;\n      continue;\n    }\n    /** @type {?} */\n\n\n    var curr = getPath(commands[i]);\n    /** @type {?} */\n\n    var next = i < commands.length - 1 ? commands[i + 1] : null;\n\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n\n  return new UrlSegmentGroup(paths, {});\n}\n/**\n * @param {?} outlets\n * @return {?}\n */\n\n\nfunction createNewSegmentChildren(outlets) {\n  /** @type {?} */\n  var children = {};\n  forEach(outlets, function (commands, outlet) {\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n/**\n * @param {?} params\n * @return {?}\n */\n\n\nfunction stringify(params) {\n  /** @type {?} */\n  var res = {};\n  forEach(params, function (v, k) {\n    return res[k] = \"\".concat(v);\n  });\n  return res;\n}\n/**\n * @param {?} path\n * @param {?} params\n * @param {?} segment\n * @return {?}\n */\n\n\nfunction compare(path, params, segment) {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nvar CanActivate = /*#__PURE__*/_createClass(\n/**\n * @param {?} path\n */\nfunction CanActivate(path) {\n  _classCallCheck(this, CanActivate);\n\n  this.path = path;\n  this.route = this.path[this.path.length - 1];\n});\n\nvar CanDeactivate = /*#__PURE__*/_createClass(\n/**\n * @param {?} component\n * @param {?} route\n */\nfunction CanDeactivate(component, route) {\n  _classCallCheck(this, CanDeactivate);\n\n  this.component = component;\n  this.route = route;\n});\n/**\n * This class bundles the actions involved in preactivation of a route.\n */\n\n\nvar PreActivation = /*#__PURE__*/function () {\n  /**\n   * @param {?} future\n   * @param {?} curr\n   * @param {?} moduleInjector\n   * @param {?=} forwardEvent\n   */\n  function PreActivation(future, curr, moduleInjector, forwardEvent) {\n    _classCallCheck(this, PreActivation);\n\n    this.future = future;\n    this.curr = curr;\n    this.moduleInjector = moduleInjector;\n    this.forwardEvent = forwardEvent;\n    this.canActivateChecks = [];\n    this.canDeactivateChecks = [];\n  }\n  /**\n   * @param {?} parentContexts\n   * @return {?}\n   */\n\n\n  _createClass(PreActivation, [{\n    key: \"initialize\",\n    value: function initialize(parentContexts) {\n      /** @type {?} */\n      var futureRoot = this.future._root;\n      /** @type {?} */\n\n      var currRoot = this.curr ? this.curr._root : null;\n      this.setupChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkGuards\",\n    value: function checkGuards() {\n      var _this23 = this;\n\n      if (!this.isDeactivating() && !this.isActivating()) {\n        return of(true);\n      }\n      /** @type {?} */\n\n\n      var canDeactivate$ = this.runCanDeactivateChecks();\n      return canDeactivate$.pipe(mergeMap(function (canDeactivate) {\n        return canDeactivate ? _this23.runCanActivateChecks() : of(false);\n      }));\n    }\n    /**\n     * @param {?} paramsInheritanceStrategy\n     * @return {?}\n     */\n\n  }, {\n    key: \"resolveData\",\n    value: function resolveData(paramsInheritanceStrategy) {\n      var _this24 = this;\n\n      if (!this.isActivating()) return of(null);\n      return from(this.canActivateChecks).pipe(concatMap(function (check) {\n        return _this24.runResolve(check.route, paramsInheritanceStrategy);\n      }), reduce(function (_, __) {\n        return _;\n      }));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"isDeactivating\",\n    value: function isDeactivating() {\n      return this.canDeactivateChecks.length !== 0;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"isActivating\",\n    value: function isActivating() {\n      return this.canActivateChecks.length !== 0;\n    }\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n\n  }, {\n    key: \"setupChildRouteGuards\",\n    value: function setupChildRouteGuards(futureNode, currNode, contexts, futurePath) {\n      var _this25 = this;\n\n      /** @type {?} */\n      var prevChildren = nodeChildrenAsMap(currNode); // Process the children of the future route\n\n      futureNode.children.forEach(function (c) {\n        _this25.setupRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));\n\n        delete prevChildren[c.value.outlet];\n      }); // Process any children left from the current route (not active for the future route)\n\n      forEach(prevChildren, function (v, k) {\n        return _this25.deactivateRouteAndItsChildren(v,\n        /** @type {?} */\n        contexts.getContext(k));\n      });\n    }\n    /**\n     * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n     * proper state to run `checkGuards()` method.\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @param {?} futurePath\n     * @return {?}\n     */\n\n  }, {\n    key: \"setupRouteGuards\",\n    value: function setupRouteGuards(futureNode, currNode, parentContexts, futurePath) {\n      /** @type {?} */\n      var future = futureNode.value;\n      /** @type {?} */\n\n      var curr = currNode ? currNode.value : null;\n      /** @type {?} */\n\n      var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null; // reusing the node\n\n      if (curr && future.routeConfig === curr.routeConfig) {\n        /** @type {?} */\n        var shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(curr, future,\n        /** @type {?} */\n        future.routeConfig.runGuardsAndResolvers);\n\n        if (shouldRunGuardsAndResolvers) {\n          this.canActivateChecks.push(new CanActivate(futurePath));\n        } else {\n          // we need to set the data\n          future.data = curr.data;\n          future._resolvedData = curr._resolvedData;\n        } // If we have a component, we need to go through an outlet.\n\n\n        if (future.component) {\n          this.setupChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath); // if we have a componentless route, we recurse but keep the same outlet map.\n        } else {\n          this.setupChildRouteGuards(futureNode, currNode, parentContexts, futurePath);\n        }\n\n        if (shouldRunGuardsAndResolvers) {\n          /** @type {?} */\n          var outlet =\n          /** @type {?} */\n\n          /** @type {?} */\n          context.outlet;\n          this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));\n        }\n      } else {\n        if (curr) {\n          this.deactivateRouteAndItsChildren(currNode, context);\n        }\n\n        this.canActivateChecks.push(new CanActivate(futurePath)); // If we have a component, we need to go through an outlet.\n\n        if (future.component) {\n          this.setupChildRouteGuards(futureNode, null, context ? context.children : null, futurePath); // if we have a componentless route, we recurse but keep the same outlet map.\n        } else {\n          this.setupChildRouteGuards(futureNode, null, parentContexts, futurePath);\n        }\n      }\n    }\n    /**\n     * @param {?} curr\n     * @param {?} future\n     * @param {?} mode\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldRunGuardsAndResolvers\",\n    value: function shouldRunGuardsAndResolvers(curr, future, mode) {\n      switch (mode) {\n        case 'always':\n          return true;\n\n        case 'paramsOrQueryParamsChange':\n          return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);\n\n        case 'paramsChange':\n        default:\n          return !equalParamsAndUrlSegments(curr, future);\n      }\n    }\n    /**\n     * @param {?} route\n     * @param {?} context\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRouteAndItsChildren\",\n    value: function deactivateRouteAndItsChildren(route, context) {\n      var _this26 = this;\n\n      /** @type {?} */\n      var children = nodeChildrenAsMap(route);\n      /** @type {?} */\n\n      var r = route.value;\n      forEach(children, function (node, childName) {\n        if (!r.component) {\n          _this26.deactivateRouteAndItsChildren(node, context);\n        } else if (context) {\n          _this26.deactivateRouteAndItsChildren(node, context.children.getContext(childName));\n        } else {\n          _this26.deactivateRouteAndItsChildren(node, null);\n        }\n      });\n\n      if (!r.component) {\n        this.canDeactivateChecks.push(new CanDeactivate(null, r));\n      } else if (context && context.outlet && context.outlet.isActivated) {\n        this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n      } else {\n        this.canDeactivateChecks.push(new CanDeactivate(null, r));\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanDeactivateChecks\",\n    value: function runCanDeactivateChecks() {\n      var _this27 = this;\n\n      return from(this.canDeactivateChecks).pipe(mergeMap(function (check) {\n        return _this27.runCanDeactivate(check.component, check.route);\n      }), every(function (result) {\n        return result === true;\n      }));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanActivateChecks\",\n    value: function runCanActivateChecks() {\n      var _this28 = this;\n\n      return from(this.canActivateChecks).pipe(concatMap(function (check) {\n        return andObservables(from([_this28.fireChildActivationStart(check.route.parent), _this28.fireActivationStart(check.route), _this28.runCanActivateChild(check.path), _this28.runCanActivate(check.route)]));\n      }), every(function (result) {\n        return result === true;\n      })); // this.fireChildActivationStart(check.path),\n    }\n    /**\n     * This should fire off `ActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n\n  }, {\n    key: \"fireActivationStart\",\n    value: function fireActivationStart(snapshot) {\n      if (snapshot !== null && this.forwardEvent) {\n        this.forwardEvent(new ActivationStart(snapshot));\n      }\n\n      return of(true);\n    }\n    /**\n     * This should fire off `ChildActivationStart` events for each route being activated at this\n     * level.\n     * In other words, if you're activating `a` and `b` below, `path` will contain the\n     * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n     * return\n     * `true` so checks continue to run.\n     * @param {?} snapshot\n     * @return {?}\n     */\n\n  }, {\n    key: \"fireChildActivationStart\",\n    value: function fireChildActivationStart(snapshot) {\n      if (snapshot !== null && this.forwardEvent) {\n        this.forwardEvent(new ChildActivationStart(snapshot));\n      }\n\n      return of(true);\n    }\n    /**\n     * @param {?} future\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanActivate\",\n    value: function runCanActivate(future) {\n      var _this29 = this;\n\n      /** @type {?} */\n      var canActivate = future.routeConfig ? future.routeConfig.canActivate : null;\n      if (!canActivate || canActivate.length === 0) return of(true);\n      /** @type {?} */\n\n      var obs = from(canActivate).pipe(map(function (c) {\n        /** @type {?} */\n        var guard = _this29.getToken(c, future);\n        /** @type {?} */\n\n\n        var observable;\n\n        if (guard.canActivate) {\n          observable = wrapIntoObservable(guard.canActivate(future, _this29.future));\n        } else {\n          observable = wrapIntoObservable(guard(future, _this29.future));\n        }\n\n        return observable.pipe(first());\n      }));\n      return andObservables(obs);\n    }\n    /**\n     * @param {?} path\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanActivateChild\",\n    value: function runCanActivateChild(path) {\n      var _this30 = this;\n\n      /** @type {?} */\n      var future = path[path.length - 1];\n      /** @type {?} */\n\n      var canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(function (p) {\n        return _this30.extractCanActivateChild(p);\n      }).filter(function (_) {\n        return _ !== null;\n      });\n      return andObservables(from(canActivateChildGuards).pipe(map(function (d) {\n        /** @type {?} */\n        var obs = from(d.guards).pipe(map(function (c) {\n          /** @type {?} */\n          var guard = _this30.getToken(c, d.node);\n          /** @type {?} */\n\n\n          var observable;\n\n          if (guard.canActivateChild) {\n            observable = wrapIntoObservable(guard.canActivateChild(future, _this30.future));\n          } else {\n            observable = wrapIntoObservable(guard(future, _this30.future));\n          }\n\n          return observable.pipe(first());\n        }));\n        return andObservables(obs);\n      })));\n    }\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n\n  }, {\n    key: \"extractCanActivateChild\",\n    value: function extractCanActivateChild(p) {\n      /** @type {?} */\n      var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n      if (!canActivateChild || canActivateChild.length === 0) return null;\n      return {\n        node: p,\n        guards: canActivateChild\n      };\n    }\n    /**\n     * @param {?} component\n     * @param {?} curr\n     * @return {?}\n     */\n\n  }, {\n    key: \"runCanDeactivate\",\n    value: function runCanDeactivate(component, curr) {\n      var _this31 = this;\n\n      /** @type {?} */\n      var canDeactivate = curr && curr.routeConfig ? curr.routeConfig.canDeactivate : null;\n      if (!canDeactivate || canDeactivate.length === 0) return of(true);\n      /** @type {?} */\n\n      var canDeactivate$ = from(canDeactivate).pipe(mergeMap(function (c) {\n        /** @type {?} */\n        var guard = _this31.getToken(c, curr);\n        /** @type {?} */\n\n\n        var observable;\n\n        if (guard.canDeactivate) {\n          observable = wrapIntoObservable(guard.canDeactivate(component, curr, _this31.curr, _this31.future));\n        } else {\n          observable = wrapIntoObservable(guard(component, curr, _this31.curr, _this31.future));\n        }\n\n        return observable.pipe(first());\n      }));\n      return canDeactivate$.pipe(every(function (result) {\n        return result === true;\n      }));\n    }\n    /**\n     * @param {?} future\n     * @param {?} paramsInheritanceStrategy\n     * @return {?}\n     */\n\n  }, {\n    key: \"runResolve\",\n    value: function runResolve(future, paramsInheritanceStrategy) {\n      /** @type {?} */\n      var resolve = future._resolve;\n      return this.resolveNode(resolve, future).pipe(map(function (resolvedData) {\n        future._resolvedData = resolvedData;\n        future.data = Object.assign({}, future.data, inheritedParamsDataResolve(future, paramsInheritanceStrategy).resolve);\n        return null;\n      }));\n    }\n    /**\n     * @param {?} resolve\n     * @param {?} future\n     * @return {?}\n     */\n\n  }, {\n    key: \"resolveNode\",\n    value: function resolveNode(resolve, future) {\n      var _this32 = this;\n\n      /** @type {?} */\n      var keys = Object.keys(resolve);\n\n      if (keys.length === 0) {\n        return of({});\n      }\n\n      if (keys.length === 1) {\n        /** @type {?} */\n        var key = keys[0];\n        return this.getResolver(resolve[key], future).pipe(map(function (value) {\n          return _defineProperty({}, key, value);\n        }));\n      }\n      /** @type {?} */\n\n\n      var data = {};\n      /** @type {?} */\n\n      var runningResolvers$ = from(keys).pipe(mergeMap(function (key) {\n        return _this32.getResolver(resolve[key], future).pipe(map(function (value) {\n          data[key] = value;\n          return value;\n        }));\n      }));\n      return runningResolvers$.pipe(last(), map(function () {\n        return data;\n      }));\n    }\n    /**\n     * @param {?} injectionToken\n     * @param {?} future\n     * @return {?}\n     */\n\n  }, {\n    key: \"getResolver\",\n    value: function getResolver(injectionToken, future) {\n      /** @type {?} */\n      var resolver = this.getToken(injectionToken, future);\n      return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) : wrapIntoObservable(resolver(future, this.future));\n    }\n    /**\n     * @param {?} token\n     * @param {?} snapshot\n     * @return {?}\n     */\n\n  }, {\n    key: \"getToken\",\n    value: function getToken(token, snapshot) {\n      /** @type {?} */\n      var config = closestLoadedConfig(snapshot);\n      /** @type {?} */\n\n      var injector = config ? config.module.injector : this.moduleInjector;\n      return injector.get(token);\n    }\n  }]);\n\n  return PreActivation;\n}();\n/**\n * @param {?} snapshot\n * @return {?}\n */\n\n\nfunction closestLoadedConfig(snapshot) {\n  if (!snapshot) return null;\n\n  for (var s = snapshot.parent; s; s = s.parent) {\n    /** @type {?} */\n    var route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n  }\n\n  return null;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nvar NoMatch$1 = /*#__PURE__*/_createClass(function NoMatch$1() {\n  _classCallCheck(this, NoMatch$1);\n});\n/**\n * @param {?} rootComponentType\n * @param {?} config\n * @param {?} urlTree\n * @param {?} url\n * @param {?=} paramsInheritanceStrategy\n * @param {?=} relativeLinkResolution\n * @return {?}\n */\n\n\nfunction recognize(rootComponentType, config, urlTree, url) {\n  var paramsInheritanceStrategy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'emptyOnly';\n  var relativeLinkResolution = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'legacy';\n  return new Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution).recognize();\n}\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\n   * @param {?} rootComponentType\n   * @param {?} config\n   * @param {?} urlTree\n   * @param {?} url\n   * @param {?} paramsInheritanceStrategy\n   * @param {?} relativeLinkResolution\n   */\n  function Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {\n    _classCallCheck(this, Recognizer);\n\n    this.rootComponentType = rootComponentType;\n    this.config = config;\n    this.urlTree = urlTree;\n    this.url = url;\n    this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n    this.relativeLinkResolution = relativeLinkResolution;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Recognizer, [{\n    key: \"recognize\",\n    value: function recognize() {\n      try {\n        /** @type {?} */\n        var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;\n        /** @type {?} */\n\n        var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n        /** @type {?} */\n\n        var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)),\n        /** @type {?} */\n        this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n        /** @type {?} */\n\n        var rootNode = new TreeNode(root, children);\n        /** @type {?} */\n\n        var routeState = new RouterStateSnapshot(this.url, rootNode);\n        this.inheritParamsAndData(routeState._root);\n        return of(routeState);\n      } catch (e) {\n        return new Observable(function (obs) {\n          return obs.error(e);\n        });\n      }\n    }\n    /**\n     * @param {?} routeNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"inheritParamsAndData\",\n    value: function inheritParamsAndData(routeNode) {\n      var _this33 = this;\n\n      /** @type {?} */\n      var route = routeNode.value;\n      /** @type {?} */\n\n      var i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);\n      route.params = Object.freeze(i.params);\n      route.data = Object.freeze(i.data);\n      routeNode.children.forEach(function (n) {\n        return _this33.inheritParamsAndData(n);\n      });\n    }\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"processSegmentGroup\",\n    value: function processSegmentGroup(config, segmentGroup, outlet) {\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return this.processChildren(config, segmentGroup);\n      }\n\n      return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n    }\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n\n  }, {\n    key: \"processChildren\",\n    value: function processChildren(config, segmentGroup) {\n      var _this34 = this;\n\n      /** @type {?} */\n      var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) {\n        return _this34.processSegmentGroup(config, child, childOutlet);\n      });\n      checkOutletNameUniqueness(children);\n      sortActivatedRouteSnapshots(children);\n      return children;\n    }\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"processSegment\",\n    value: function processSegment(config, segmentGroup, segments, outlet) {\n      var _iterator7 = _createForOfIteratorHelper(config),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var r = _step7.value;\n\n          try {\n            return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n          } catch (e) {\n            if (!(e instanceof NoMatch$1)) throw e;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n        return [];\n      }\n\n      throw new NoMatch$1();\n    }\n    /**\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"noLeftoversInUrl\",\n    value: function noLeftoversInUrl(segmentGroup, segments, outlet) {\n      return segments.length === 0 && !segmentGroup.children[outlet];\n    }\n    /**\n     * @param {?} route\n     * @param {?} rawSegment\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"processSegmentAgainstRoute\",\n    value: function processSegmentAgainstRoute(route, rawSegment, segments, outlet) {\n      if (route.redirectTo) throw new NoMatch$1();\n      if ((route.outlet || PRIMARY_OUTLET) !== outlet) throw new NoMatch$1();\n      /** @type {?} */\n\n      var snapshot;\n      /** @type {?} */\n\n      var consumedSegments = [];\n      /** @type {?} */\n\n      var rawSlicedSegments = [];\n\n      if (route.path === '**') {\n        /** @type {?} */\n        var params = segments.length > 0 ?\n        /** @type {?} */\n        last$1(segments).parameters : {};\n        snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(Object.assign({}, this.urlTree.queryParams)),\n        /** @type {?} */\n        this.urlTree.fragment, getData(route), outlet,\n        /** @type {?} */\n        route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n      } else {\n        /** @type {?} */\n        var result = match$1(rawSegment, route, segments);\n        consumedSegments = result.consumedSegments;\n        rawSlicedSegments = segments.slice(result.lastChild);\n        snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)),\n        /** @type {?} */\n        this.urlTree.fragment, getData(route), outlet,\n        /** @type {?} */\n        route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n      }\n      /** @type {?} */\n\n\n      var childConfig = getChildConfig(route);\n\n      var _split$ = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution),\n          segmentGroup = _split$.segmentGroup,\n          slicedSegments = _split$.slicedSegments;\n\n      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n        /** @type {?} */\n        var _children3 = this.processChildren(childConfig, segmentGroup);\n\n        return [new TreeNode(snapshot, _children3)];\n      }\n\n      if (childConfig.length === 0 && slicedSegments.length === 0) {\n        return [new TreeNode(snapshot, [])];\n      }\n      /** @type {?} */\n\n\n      var children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n      return [new TreeNode(snapshot, children)];\n    }\n  }]);\n\n  return Recognizer;\n}();\n/**\n * @param {?} nodes\n * @return {?}\n */\n\n\nfunction sortActivatedRouteSnapshots(nodes) {\n  nodes.sort(function (a, b) {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getChildConfig(route) {\n  if (route.children) {\n    return route.children;\n  }\n\n  if (route.loadChildren) {\n    return (\n      /** @type {?} */\n      route._loadedConfig.routes\n    );\n  }\n\n  return [];\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\n\n\nfunction match$1(segmentGroup, route, segments) {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      throw new NoMatch$1();\n    }\n\n    return {\n      consumedSegments: [],\n      lastChild: 0,\n      parameters: {}\n    };\n  }\n  /** @type {?} */\n\n\n  var matcher = route.matcher || defaultUrlMatcher;\n  /** @type {?} */\n\n  var res = matcher(segments, segmentGroup, route);\n  if (!res) throw new NoMatch$1();\n  /** @type {?} */\n\n  var posParams = {};\n  forEach(\n  /** @type {?} */\n  res.posParams, function (v, k) {\n    posParams[k] = v.path;\n  });\n  /** @type {?} */\n\n  var parameters = res.consumed.length > 0 ? Object.assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) : posParams;\n  return {\n    consumedSegments: res.consumed,\n    lastChild: res.consumed.length,\n    parameters: parameters\n  };\n}\n/**\n * @param {?} nodes\n * @return {?}\n */\n\n\nfunction checkOutletNameUniqueness(nodes) {\n  /** @type {?} */\n  var names = {};\n  nodes.forEach(function (n) {\n    /** @type {?} */\n    var routeWithSameOutletName = names[n.value.outlet];\n\n    if (routeWithSameOutletName) {\n      /** @type {?} */\n      var p = routeWithSameOutletName.url.map(function (s) {\n        return s.toString();\n      }).join('/');\n      /** @type {?} */\n\n      var c = n.value.url.map(function (s) {\n        return s.toString();\n      }).join('/');\n      throw new Error(\"Two segments cannot have the same outlet name: '\".concat(p, \"' and '\").concat(c, \"'.\"));\n    }\n\n    names[n.value.outlet] = n.value;\n  });\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\n\n\nfunction getSourceSegmentGroup(segmentGroup) {\n  /** @type {?} */\n  var s = segmentGroup;\n\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n  }\n\n  return s;\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\n\n\nfunction getPathIndexShift(segmentGroup) {\n  /** @type {?} */\n  var s = segmentGroup;\n  /** @type {?} */\n\n  var res = s._segmentIndexShift ? s._segmentIndexShift : 0;\n\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n    res += s._segmentIndexShift ? s._segmentIndexShift : 0;\n  }\n\n  return res - 1;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @param {?} relativeLinkResolution\n * @return {?}\n */\n\n\nfunction split$1(segmentGroup, consumedSegments, slicedSegments, config, relativeLinkResolution) {\n  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    /** @type {?} */\n    var _s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\n    _s2._sourceSegment = segmentGroup;\n    _s2._segmentIndexShift = consumedSegments.length;\n    return {\n      segmentGroup: _s2,\n      slicedSegments: []\n    };\n  }\n\n  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    /** @type {?} */\n    var _s3 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));\n\n    _s3._sourceSegment = segmentGroup;\n    _s3._segmentIndexShift = consumedSegments.length;\n    return {\n      segmentGroup: _s3,\n      slicedSegments: slicedSegments\n    };\n  }\n  /** @type {?} */\n\n\n  var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  s._sourceSegment = segmentGroup;\n  s._segmentIndexShift = consumedSegments.length;\n  return {\n    segmentGroup: s,\n    slicedSegments: slicedSegments\n  };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @param {?} relativeLinkResolution\n * @return {?}\n */\n\n\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {\n  /** @type {?} */\n  var res = {};\n\n  var _iterator8 = _createForOfIteratorHelper(routes),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var r = _step8.value;\n\n      if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n        /** @type {?} */\n        var s = new UrlSegmentGroup([], {});\n        s._sourceSegment = segmentGroup;\n\n        if (relativeLinkResolution === 'legacy') {\n          s._segmentIndexShift = segmentGroup.segments.length;\n        } else {\n          s._segmentIndexShift = consumedSegments.length;\n        }\n\n        res[getOutlet$1(r)] = s;\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return Object.assign({}, children, res);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} routes\n * @param {?} primarySegment\n * @return {?}\n */\n\n\nfunction createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n  /** @type {?} */\n  var res = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  primarySegment._sourceSegment = segmentGroup;\n  primarySegment._segmentIndexShift = consumedSegments.length;\n\n  var _iterator9 = _createForOfIteratorHelper(routes),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var r = _step9.value;\n\n      if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n        /** @type {?} */\n        var s = new UrlSegmentGroup([], {});\n        s._sourceSegment = segmentGroup;\n        s._segmentIndexShift = consumedSegments.length;\n        res[getOutlet$1(r)] = s;\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n  return routes.some(function (r) {\n    return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET;\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n  return routes.some(function (r) {\n    return emptyPathMatch(segmentGroup, slicedSegments, r);\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} r\n * @return {?}\n */\n\n\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '' && r.redirectTo === undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getOutlet$1(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getData(route) {\n  return route.data || {};\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getResolve(route) {\n  return route.resolve || {};\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * \\@experimental\n * @abstract\n */\n\n\nvar RouteReuseStrategy = /*#__PURE__*/_createClass(function RouteReuseStrategy() {\n  _classCallCheck(this, RouteReuseStrategy);\n});\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\n\n\nvar DefaultRouteReuseStrategy = /*#__PURE__*/function () {\n  function DefaultRouteReuseStrategy() {\n    _classCallCheck(this, DefaultRouteReuseStrategy);\n  }\n\n  _createClass(DefaultRouteReuseStrategy, [{\n    key: \"shouldDetach\",\n    value:\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    function shouldDetach(route) {\n      return false;\n    }\n    /**\n     * @param {?} route\n     * @param {?} detachedTree\n     * @return {?}\n     */\n\n  }, {\n    key: \"store\",\n    value: function store(route, detachedTree) {}\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldAttach\",\n    value: function shouldAttach(route) {\n      return false;\n    }\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(route) {\n      return null;\n    }\n    /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldReuseRoute\",\n    value: function shouldReuseRoute(future, curr) {\n      return future.routeConfig === curr.routeConfig;\n    }\n  }]);\n\n  return DefaultRouteReuseStrategy;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * \\@docsNotRequired\n * \\@experimental\n  @type {?} */\n\n\nvar ROUTES = /*#__PURE__*/new InjectionToken('ROUTES');\n\nvar RouterConfigLoader = /*#__PURE__*/function () {\n  /**\n   * @param {?} loader\n   * @param {?} compiler\n   * @param {?=} onLoadStartListener\n   * @param {?=} onLoadEndListener\n   */\n  function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {\n    _classCallCheck(this, RouterConfigLoader);\n\n    this.loader = loader;\n    this.compiler = compiler;\n    this.onLoadStartListener = onLoadStartListener;\n    this.onLoadEndListener = onLoadEndListener;\n  }\n  /**\n   * @param {?} parentInjector\n   * @param {?} route\n   * @return {?}\n   */\n\n\n  _createClass(RouterConfigLoader, [{\n    key: \"load\",\n    value: function load(parentInjector, route) {\n      var _this35 = this;\n\n      if (this.onLoadStartListener) {\n        this.onLoadStartListener(route);\n      }\n      /** @type {?} */\n\n\n      var moduleFactory$ = this.loadModuleFactory(\n      /** @type {?} */\n      route.loadChildren);\n      return moduleFactory$.pipe(map(function (factory) {\n        if (_this35.onLoadEndListener) {\n          _this35.onLoadEndListener(route);\n        }\n        /** @type {?} */\n\n\n        var module = factory.create(parentInjector);\n        return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);\n      }));\n    }\n    /**\n     * @param {?} loadChildren\n     * @return {?}\n     */\n\n  }, {\n    key: \"loadModuleFactory\",\n    value: function loadModuleFactory(loadChildren) {\n      var _this36 = this;\n\n      if (typeof loadChildren === 'string') {\n        return from(this.loader.load(loadChildren));\n      } else {\n        return wrapIntoObservable(loadChildren()).pipe(mergeMap(function (t) {\n          if (t instanceof NgModuleFactory) {\n            return of(t);\n          } else {\n            return from(_this36.compiler.compileModuleAsync(t));\n          }\n        }));\n      }\n    }\n  }]);\n\n  return RouterConfigLoader;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * \\@experimental\n * @abstract\n */\n\n\nvar UrlHandlingStrategy = /*#__PURE__*/_createClass(function UrlHandlingStrategy() {\n  _classCallCheck(this, UrlHandlingStrategy);\n});\n/**\n * \\@experimental\n */\n\n\nvar DefaultUrlHandlingStrategy = /*#__PURE__*/function () {\n  function DefaultUrlHandlingStrategy() {\n    _classCallCheck(this, DefaultUrlHandlingStrategy);\n  }\n\n  _createClass(DefaultUrlHandlingStrategy, [{\n    key: \"shouldProcessUrl\",\n    value:\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    function shouldProcessUrl(url) {\n      return true;\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n\n  }, {\n    key: \"extract\",\n    value: function extract(url) {\n      return url;\n    }\n    /**\n     * @param {?} newUrlPart\n     * @param {?} wholeUrl\n     * @return {?}\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(newUrlPart, wholeUrl) {\n      return newUrlPart;\n    }\n  }]);\n\n  return DefaultUrlHandlingStrategy;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} error\n * @return {?}\n */\n\n\nfunction defaultErrorHandler(error) {\n  throw error;\n}\n/**\n * @param {?} error\n * @param {?} urlSerializer\n * @param {?} url\n * @return {?}\n */\n\n\nfunction defaultMalformedUriErrorHandler(error, urlSerializer, url) {\n  return urlSerializer.parse('/');\n}\n/**\n * \\@internal\n * @param {?} snapshot\n * @param {?} runExtras\n * @return {?}\n */\n\n\nfunction defaultRouterHook(snapshot, runExtras) {\n  return (\n    /** @type {?} */\n    of(null)\n  );\n}\n/**\n * \\@description\n *\n * Provides the navigation and url manipulation capabilities.\n *\n * See `Routes` for more details and examples.\n *\n * \\@ngModule RouterModule\n *\n *\n */\n\n\nvar Router = /*#__PURE__*/(function () {\n  var Router = /*#__PURE__*/function () {\n    /**\n     * Creates the router service.\n     * @param {?} rootComponentType\n     * @param {?} urlSerializer\n     * @param {?} rootContexts\n     * @param {?} location\n     * @param {?} injector\n     * @param {?} loader\n     * @param {?} compiler\n     * @param {?} config\n     */\n    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {\n      var _this37 = this;\n\n      _classCallCheck(this, Router);\n\n      this.rootComponentType = rootComponentType;\n      this.urlSerializer = urlSerializer;\n      this.rootContexts = rootContexts;\n      this.location = location;\n      this.config = config;\n      this.navigations = new BehaviorSubject(\n      /** @type {?} */\n      null);\n      this.navigationId = 0;\n      this.isNgZoneEnabled = false;\n      this.events = new Subject();\n      /**\n       * Error handler that is invoked when a navigation errors.\n       *\n       * See `ErrorHandler` for more information.\n       */\n\n      this.errorHandler = defaultErrorHandler;\n      /**\n       * Malformed uri error handler is invoked when `Router.parseUrl(url)` throws an\n       * error due to containing an invalid character. The most common case would be a `%` sign\n       * that's not encoded and is not part of a percent encoded sequence.\n       */\n\n      this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;\n      /**\n       * Indicates if at least one navigation happened.\n       */\n\n      this.navigated = false;\n      this.lastSuccessfulId = -1;\n      /**\n       * Used by RouterModule. This allows us to\n       * pause the navigation either before preactivation or after it.\n       * \\@internal\n       */\n\n      this.hooks = {\n        beforePreactivation: defaultRouterHook,\n        afterPreactivation: defaultRouterHook\n      };\n      /**\n       * Extracts and merges URLs. Used for AngularJS to Angular migrations.\n       */\n\n      this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n      this.routeReuseStrategy = new DefaultRouteReuseStrategy();\n      /**\n       * Define what the router should do if it receives a navigation request to the current URL.\n       * By default, the router will ignore this navigation. However, this prevents features such\n       * as a \"refresh\" button. Use this option to configure the behavior when navigating to the\n       * current URL. Default is 'ignore'.\n       */\n\n      this.onSameUrlNavigation = 'ignore';\n      /**\n       * Defines how the router merges params, data and resolved data from parent to child\n       * routes. Available options are:\n       *\n       * - `'emptyOnly'`, the default, only inherits parent params for path-less or component-less\n       *   routes.\n       * - `'always'`, enables unconditional inheritance of parent params.\n       */\n\n      this.paramsInheritanceStrategy = 'emptyOnly';\n      /**\n       * Defines when the router updates the browser URL. The default behavior is to update after\n       * successful navigation. However, some applications may prefer a mode where the URL gets\n       * updated at the beginning of navigation. The most common use case would be updating the\n       * URL early so if navigation fails, you can show an error message with the URL that failed.\n       * Available options are:\n       *\n       * - `'deferred'`, the default, updates the browser URL after navigation has finished.\n       * - `'eager'`, updates browser URL at the beginning of navigation.\n       */\n\n      this.urlUpdateStrategy = 'deferred';\n      /**\n       * See {\\@link RouterModule} for more information.\n       */\n\n      this.relativeLinkResolution = 'legacy';\n      /** @type {?} */\n\n      var onLoadStart = function onLoadStart(r) {\n        return _this37.triggerEvent(new RouteConfigLoadStart(r));\n      };\n      /** @type {?} */\n\n\n      var onLoadEnd = function onLoadEnd(r) {\n        return _this37.triggerEvent(new RouteConfigLoadEnd(r));\n      };\n\n      this.ngModule = injector.get(NgModuleRef);\n      this.console = injector.get(ɵConsole);\n      /** @type {?} */\n\n      var ngZone = injector.get(NgZone);\n      this.isNgZoneEnabled = ngZone instanceof NgZone;\n      this.resetConfig(config);\n      this.currentUrlTree = createEmptyUrlTree();\n      this.rawUrlTree = this.currentUrlTree;\n      this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);\n      this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n      this.processNavigations();\n    }\n    /**\n     * \\@internal\n     * TODO: this should be removed once the constructor of the router made internal\n     * @param {?} rootComponentType\n     * @return {?}\n     */\n\n\n    _createClass(Router, [{\n      key: \"resetRootComponentType\",\n      value: function resetRootComponentType(rootComponentType) {\n        this.rootComponentType = rootComponentType; // TODO: vsavkin router 4.0 should make the root component set to null\n        // this will simplify the lifecycle of the router.\n\n        this.routerState.root.component = this.rootComponentType;\n      }\n      /**\n       * Sets up the location change listener and performs the initial navigation.\n       * @return {?}\n       */\n\n    }, {\n      key: \"initialNavigation\",\n      value: function initialNavigation() {\n        this.setUpLocationChangeListener();\n\n        if (this.navigationId === 0) {\n          this.navigateByUrl(this.location.path(true), {\n            replaceUrl: true\n          });\n        }\n      }\n      /**\n       * Sets up the location change listener.\n       * @return {?}\n       */\n\n    }, {\n      key: \"setUpLocationChangeListener\",\n      value: function setUpLocationChangeListener() {\n        var _this38 = this;\n\n        // Don't need to use Zone.wrap any more, because zone.js\n        // already patch onPopState, so location change callback will\n        // run into ngZone\n        if (!this.locationSubscription) {\n          this.locationSubscription =\n          /** @type {?} */\n          this.location.subscribe(function (change) {\n            /** @type {?} */\n            var rawUrlTree = _this38.parseUrl(change['url']);\n            /** @type {?} */\n\n\n            var source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n            /** @type {?} */\n\n            var state = change.state && change.state.navigationId ? {\n              navigationId: change.state.navigationId\n            } : null;\n            setTimeout(function () {\n              _this38.scheduleNavigation(rawUrlTree, source, state, {\n                replaceUrl: true\n              });\n            }, 0);\n          });\n        }\n      }\n      /**\n       * The current url\n       * @return {?}\n       */\n\n    }, {\n      key: \"url\",\n      get: function get() {\n        return this.serializeUrl(this.currentUrlTree);\n      }\n      /**\n       * \\@internal\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"triggerEvent\",\n      value: function triggerEvent(event) {\n        /** @type {?} */\n        this.events.next(event);\n      }\n      /**\n       * Resets the configuration used for navigation and generating links.\n       *\n       * \\@usageNotes\n       *\n       * ### Example\n       *\n       * ```\n       * router.resetConfig([\n       *  { path: 'team/:id', component: TeamCmp, children: [\n       *    { path: 'simple', component: SimpleCmp },\n       *    { path: 'user/:name', component: UserCmp }\n       *  ]}\n       * ]);\n       * ```\n       * @param {?} config\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetConfig\",\n      value: function resetConfig(config) {\n        validateConfig(config);\n        this.config = config.map(standardizeConfig);\n        this.navigated = false;\n        this.lastSuccessfulId = -1;\n      }\n      /**\n       * \\@docsNotRequired\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.dispose();\n      }\n      /**\n       * Disposes of the router\n       * @return {?}\n       */\n\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this.locationSubscription) {\n          this.locationSubscription.unsubscribe();\n          this.locationSubscription =\n          /** @type {?} */\n          null;\n        }\n      }\n      /**\n       * Applies an array of commands to the current url tree and creates a new url tree.\n       *\n       * When given an activate route, applies the given commands starting from the route.\n       * When not given a route, applies the given command starting from the root.\n       *\n       * \\@usageNotes\n       *\n       * ### Example\n       *\n       * ```\n       * // create /team/33/user/11\n       * router.createUrlTree(['/team', 33, 'user', 11]);\n       *\n       * // create /team/33;expand=true/user/11\n       * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n       *\n       * // you can collapse static segments like this (this works only with the first passed-in value):\n       * router.createUrlTree(['/team/33/user', userId]);\n       *\n       * // If the first segment can contain slashes, and you do not want the router to split it, you\n       * // can do the following:\n       *\n       * router.createUrlTree([{segmentPath: '/one/two'}]);\n       *\n       * // create /team/33/(user/11//right:chat)\n       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n       *\n       * // remove the right secondary node\n       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n       *\n       * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n       *\n       * // navigate to /team/33/user/11/details\n       * router.createUrlTree(['details'], {relativeTo: route});\n       *\n       * // navigate to /team/33/user/22\n       * router.createUrlTree(['../22'], {relativeTo: route});\n       *\n       * // navigate to /team/44/user/22\n       * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n       * ```\n       * @param {?} commands\n       * @param {?=} navigationExtras\n       * @return {?}\n       */\n\n    }, {\n      key: \"createUrlTree\",\n      value: function createUrlTree(commands) {\n        var navigationExtras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var relativeTo = navigationExtras.relativeTo,\n            queryParams = navigationExtras.queryParams,\n            fragment = navigationExtras.fragment,\n            preserveQueryParams = navigationExtras.preserveQueryParams,\n            queryParamsHandling = navigationExtras.queryParamsHandling,\n            preserveFragment = navigationExtras.preserveFragment;\n\n        if (isDevMode() && preserveQueryParams &&\n        /** @type {?} */\n        console &&\n        /** @type {?} */\n        console.warn) {\n          console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n        }\n        /** @type {?} */\n\n\n        var a = relativeTo || this.routerState.root;\n        /** @type {?} */\n\n        var f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n        /** @type {?} */\n\n        var q = null;\n\n        if (queryParamsHandling) {\n          switch (queryParamsHandling) {\n            case 'merge':\n              q = Object.assign({}, this.currentUrlTree.queryParams, queryParams);\n              break;\n\n            case 'preserve':\n              q = this.currentUrlTree.queryParams;\n              break;\n\n            default:\n              q = queryParams || null;\n          }\n        } else {\n          q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;\n        }\n\n        if (q !== null) {\n          q = this.removeEmptyProps(q);\n        }\n\n        return _createUrlTree(a, this.currentUrlTree, commands,\n        /** @type {?} */\n        q,\n        /** @type {?} */\n        f);\n      }\n      /**\n       * Navigate based on the provided url. This navigation is always absolute.\n       *\n       * Returns a promise that:\n       * - resolves to 'true' when navigation succeeds,\n       * - resolves to 'false' when navigation fails,\n       * - is rejected when an error happens.\n       *\n       * \\@usageNotes\n       *\n       * ### Example\n       *\n       * ```\n       * router.navigateByUrl(\"/team/33/user/11\");\n       *\n       * // Navigate without updating the URL\n       * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n       * ```\n       *\n       * Since `navigateByUrl()` takes an absolute URL as the first parameter,\n       * it will not apply any delta to the current URL and ignores any properties\n       * in the second parameter (the `NavigationExtras`) that would change the\n       * provided URL.\n       * @param {?} url\n       * @param {?=} extras\n       * @return {?}\n       */\n\n    }, {\n      key: \"navigateByUrl\",\n      value: function navigateByUrl(url) {\n        var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          skipLocationChange: false\n        };\n\n        if (isDevMode() && this.isNgZoneEnabled && !NgZone.isInAngularZone()) {\n          this.console.warn(\"Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?\");\n        }\n        /** @type {?} */\n\n\n        var urlTree = url instanceof UrlTree ? url : this.parseUrl(url);\n        /** @type {?} */\n\n        var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n        return this.scheduleNavigation(mergedTree, 'imperative', null, extras);\n      }\n      /**\n       * Navigate based on the provided array of commands and a starting point.\n       * If no starting route is provided, the navigation is absolute.\n       *\n       * Returns a promise that:\n       * - resolves to 'true' when navigation succeeds,\n       * - resolves to 'false' when navigation fails,\n       * - is rejected when an error happens.\n       *\n       * \\@usageNotes\n       *\n       * ### Example\n       *\n       * ```\n       * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n       *\n       * // Navigate without updating the URL\n       * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n       * ```\n       *\n       * The first parameter of `navigate()` is a delta to be applied to the current URL\n       * or the one provided in the `relativeTo` property of the second parameter (the\n       * `NavigationExtras`).\n       * @param {?} commands\n       * @param {?=} extras\n       * @return {?}\n       */\n\n    }, {\n      key: \"navigate\",\n      value: function navigate(commands) {\n        var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          skipLocationChange: false\n        };\n        validateCommands(commands);\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n      }\n      /**\n       * Serializes a `UrlTree` into a string\n       * @param {?} url\n       * @return {?}\n       */\n\n    }, {\n      key: \"serializeUrl\",\n      value: function serializeUrl(url) {\n        return this.urlSerializer.serialize(url);\n      }\n      /**\n       * Parses a string into a `UrlTree`\n       * @param {?} url\n       * @return {?}\n       */\n\n    }, {\n      key: \"parseUrl\",\n      value: function parseUrl(url) {\n        /** @type {?} */\n        var urlTree;\n\n        try {\n          urlTree = this.urlSerializer.parse(url);\n        } catch (e) {\n          urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);\n        }\n\n        return urlTree;\n      }\n      /**\n       * Returns whether the url is activated\n       * @param {?} url\n       * @param {?} exact\n       * @return {?}\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive(url, exact) {\n        if (url instanceof UrlTree) {\n          return containsTree(this.currentUrlTree, url, exact);\n        }\n        /** @type {?} */\n\n\n        var urlTree = this.parseUrl(url);\n        return containsTree(this.currentUrlTree, urlTree, exact);\n      }\n      /**\n       * @param {?} params\n       * @return {?}\n       */\n\n    }, {\n      key: \"removeEmptyProps\",\n      value: function removeEmptyProps(params) {\n        return Object.keys(params).reduce(function (result, key) {\n          /** @type {?} */\n          var value = params[key];\n\n          if (value !== null && value !== undefined) {\n            result[key] = value;\n          }\n\n          return result;\n        }, {});\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"processNavigations\",\n      value: function processNavigations() {\n        var _this39 = this;\n\n        this.navigations.pipe(concatMap(function (nav) {\n          if (nav) {\n            _this39.executeScheduledNavigation(nav); // a failed navigation should not stop the router from processing\n            // further navigations => the catch\n\n\n            return nav.promise.catch(function () {});\n          } else {\n            return (\n              /** @type {?} */\n              of(null)\n            );\n          }\n        })).subscribe(function () {});\n      }\n      /**\n       * @param {?} rawUrl\n       * @param {?} source\n       * @param {?} state\n       * @param {?} extras\n       * @return {?}\n       */\n\n    }, {\n      key: \"scheduleNavigation\",\n      value: function scheduleNavigation(rawUrl, source, state, extras) {\n        /** @type {?} */\n        var lastNavigation = this.navigations.value; // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n        // and that navigation results in 'replaceState' that leads to the same URL,\n        // we should skip those.\n\n        if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n          return Promise.resolve(true); // return value is not used\n        } // Because of a bug in IE and Edge, the location class fires two events (popstate and\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n        // flicker. Handles the case when a popstate was emitted first.\n\n\n        if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n          return Promise.resolve(true); // return value is not used\n        } // Because of a bug in IE and Edge, the location class fires two events (popstate and\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n        // flicker. Handles the case when a hashchange was emitted first.\n\n\n        if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n          return Promise.resolve(true); // return value is not used\n        }\n        /** @type {?} */\n\n\n        var resolve = null;\n        /** @type {?} */\n\n        var reject = null;\n        /** @type {?} */\n\n        var promise = new Promise(function (res, rej) {\n          resolve = res;\n          reject = rej;\n        });\n        /** @type {?} */\n\n        var id = ++this.navigationId;\n        this.navigations.next({\n          id: id,\n          source: source,\n          state: state,\n          rawUrl: rawUrl,\n          extras: extras,\n          resolve: resolve,\n          reject: reject,\n          promise: promise\n        }); // Make sure that the error is propagated even though `processNavigations` catch\n        // handler does not rethrow\n\n        return promise.catch(function (e) {\n          return Promise.reject(e);\n        });\n      }\n      /**\n       * @param {?} __0\n       * @return {?}\n       */\n\n    }, {\n      key: \"executeScheduledNavigation\",\n      value: function executeScheduledNavigation(_ref4) {\n        var _this40 = this;\n\n        var id = _ref4.id,\n            rawUrl = _ref4.rawUrl,\n            extras = _ref4.extras,\n            resolve = _ref4.resolve,\n            reject = _ref4.reject,\n            source = _ref4.source,\n            state = _ref4.state;\n\n        /** @type {?} */\n        var url = this.urlHandlingStrategy.extract(rawUrl);\n        /** @type {?} */\n\n        var urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();\n\n        if ((this.onSameUrlNavigation === 'reload' ? true : urlTransition) && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n          if (this.urlUpdateStrategy === 'eager' && !extras.skipLocationChange) {\n            this.setBrowserUrl(rawUrl, !!extras.replaceUrl, id);\n          }\n\n          /** @type {?} */\n          this.events.next(new NavigationStart(id, this.serializeUrl(url), source, state));\n          Promise.resolve().then(function (_) {\n            return _this40.runNavigate(url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null);\n          }).then(resolve, reject); // we cannot process the current URL, but we could process the previous one =>\n          // we need to do some cleanup\n        } else if (urlTransition && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {\n          /** @type {?} */\n          this.events.next(new NavigationStart(id, this.serializeUrl(url), source, state));\n          Promise.resolve().then(function (_) {\n            return _this40.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this40.rootComponentType).snapshot);\n          }).then(resolve, reject);\n        } else {\n          this.rawUrlTree = rawUrl;\n          resolve(null);\n        }\n      }\n      /**\n       * @param {?} url\n       * @param {?} rawUrl\n       * @param {?} skipLocationChange\n       * @param {?} replaceUrl\n       * @param {?} id\n       * @param {?} precreatedState\n       * @return {?}\n       */\n\n    }, {\n      key: \"runNavigate\",\n      value: function runNavigate(url, rawUrl, skipLocationChange, replaceUrl, id, precreatedState) {\n        var _this41 = this;\n\n        if (id !== this.navigationId) {\n          /** @type {?} */\n          this.events.next(new NavigationCancel(id, this.serializeUrl(url), \"Navigation ID \".concat(id, \" is not equal to the current navigation id \").concat(this.navigationId)));\n          return Promise.resolve(false);\n        }\n\n        return new Promise(function (resolvePromise, rejectPromise) {\n          /** @type {?} */\n          var urlAndSnapshot$;\n\n          if (!precreatedState) {\n            /** @type {?} */\n            var moduleInjector = _this41.ngModule.injector;\n            /** @type {?} */\n\n            var redirectsApplied$ = applyRedirects(moduleInjector, _this41.configLoader, _this41.urlSerializer, url, _this41.config);\n            urlAndSnapshot$ = redirectsApplied$.pipe(mergeMap(function (appliedUrl) {\n              return recognize(_this41.rootComponentType, _this41.config, appliedUrl, _this41.serializeUrl(appliedUrl), _this41.paramsInheritanceStrategy, _this41.relativeLinkResolution).pipe(map(function (snapshot) {\n                /** @type {?} */\n                _this41.events.next(new RoutesRecognized(id, _this41.serializeUrl(url), _this41.serializeUrl(appliedUrl), snapshot));\n\n                return {\n                  appliedUrl: appliedUrl,\n                  snapshot: snapshot\n                };\n              }));\n            }));\n          } else {\n            urlAndSnapshot$ = of({\n              appliedUrl: url,\n              snapshot: precreatedState\n            });\n          }\n          /** @type {?} */\n\n\n          var beforePreactivationDone$ = urlAndSnapshot$.pipe(mergeMap(function (p) {\n            if (typeof p === 'boolean') return of(p);\n            return _this41.hooks.beforePreactivation(p.snapshot, {\n              navigationId: id,\n              appliedUrlTree: url,\n              rawUrlTree: rawUrl,\n              skipLocationChange: skipLocationChange,\n              replaceUrl: replaceUrl\n            }).pipe(map(function () {\n              return p;\n            }));\n          }));\n          /** @type {?} */\n\n          var preActivation;\n          /** @type {?} */\n\n          var preactivationSetup$ = beforePreactivationDone$.pipe(map(function (p) {\n            if (typeof p === 'boolean') return p;\n            var appliedUrl = p.appliedUrl,\n                snapshot = p.snapshot;\n            /** @type {?} */\n\n            var moduleInjector = _this41.ngModule.injector;\n            preActivation = new PreActivation(snapshot, _this41.routerState.snapshot, moduleInjector, function (evt) {\n              return _this41.triggerEvent(evt);\n            });\n            preActivation.initialize(_this41.rootContexts);\n            return {\n              appliedUrl: appliedUrl,\n              snapshot: snapshot\n            };\n          }));\n          /** @type {?} */\n\n          var preactivationCheckGuards$ = preactivationSetup$.pipe(mergeMap(function (p) {\n            if (typeof p === 'boolean' || _this41.navigationId !== id) return of(false);\n            var appliedUrl = p.appliedUrl,\n                snapshot = p.snapshot;\n\n            _this41.triggerEvent(new GuardsCheckStart(id, _this41.serializeUrl(url), _this41.serializeUrl(appliedUrl), snapshot));\n\n            return preActivation.checkGuards().pipe(map(function (shouldActivate) {\n              _this41.triggerEvent(new GuardsCheckEnd(id, _this41.serializeUrl(url), _this41.serializeUrl(appliedUrl), snapshot, shouldActivate));\n\n              return {\n                appliedUrl: appliedUrl,\n                snapshot: snapshot,\n                shouldActivate: shouldActivate\n              };\n            }));\n          }));\n          /** @type {?} */\n\n          var preactivationResolveData$ = preactivationCheckGuards$.pipe(mergeMap(function (p) {\n            if (typeof p === 'boolean' || _this41.navigationId !== id) return of(false);\n\n            if (p.shouldActivate && preActivation.isActivating()) {\n              _this41.triggerEvent(new ResolveStart(id, _this41.serializeUrl(url), _this41.serializeUrl(p.appliedUrl), p.snapshot));\n\n              return preActivation.resolveData(_this41.paramsInheritanceStrategy).pipe(map(function () {\n                _this41.triggerEvent(new ResolveEnd(id, _this41.serializeUrl(url), _this41.serializeUrl(p.appliedUrl), p.snapshot));\n\n                return p;\n              }));\n            } else {\n              return of(p);\n            }\n          }));\n          /** @type {?} */\n\n          var preactivationDone$ = preactivationResolveData$.pipe(mergeMap(function (p) {\n            if (typeof p === 'boolean' || _this41.navigationId !== id) return of(false);\n            return _this41.hooks.afterPreactivation(p.snapshot, {\n              navigationId: id,\n              appliedUrlTree: url,\n              rawUrlTree: rawUrl,\n              skipLocationChange: skipLocationChange,\n              replaceUrl: replaceUrl\n            }).pipe(map(function () {\n              return p;\n            }));\n          }));\n          /** @type {?} */\n\n          var routerState$ = preactivationDone$.pipe(map(function (p) {\n            if (typeof p === 'boolean' || _this41.navigationId !== id) return false;\n            var appliedUrl = p.appliedUrl,\n                snapshot = p.snapshot,\n                shouldActivate = p.shouldActivate;\n\n            if (shouldActivate) {\n              /** @type {?} */\n              var state = createRouterState(_this41.routeReuseStrategy, snapshot, _this41.routerState);\n              return {\n                appliedUrl: appliedUrl,\n                state: state,\n                shouldActivate: shouldActivate\n              };\n            } else {\n              return {\n                appliedUrl: appliedUrl,\n                state: null,\n                shouldActivate: shouldActivate\n              };\n            }\n          }));\n\n          _this41.activateRoutes(routerState$, _this41.routerState, _this41.currentUrlTree, id, url, rawUrl, skipLocationChange, replaceUrl, resolvePromise, rejectPromise);\n        });\n      }\n      /**\n       * Performs the logic of activating routes. This is a synchronous process by default. While this\n       * is a private method, it could be overridden to make activation asynchronous.\n       * @param {?} state\n       * @param {?} storedState\n       * @param {?} storedUrl\n       * @param {?} id\n       * @param {?} url\n       * @param {?} rawUrl\n       * @param {?} skipLocationChange\n       * @param {?} replaceUrl\n       * @param {?} resolvePromise\n       * @param {?} rejectPromise\n       * @return {?}\n       */\n\n    }, {\n      key: \"activateRoutes\",\n      value: function activateRoutes(state, storedState, storedUrl, id, url, rawUrl, skipLocationChange, replaceUrl, resolvePromise, rejectPromise) {\n        var _this42 = this;\n\n        /** @type {?} */\n        var navigationIsSuccessful;\n        state.forEach(function (p) {\n          if (typeof p === 'boolean' || !p.shouldActivate || id !== _this42.navigationId || !p.state) {\n            navigationIsSuccessful = false;\n            return;\n          }\n\n          var appliedUrl = p.appliedUrl,\n              state = p.state;\n          _this42.currentUrlTree = appliedUrl;\n          _this42.rawUrlTree = _this42.urlHandlingStrategy.merge(_this42.currentUrlTree, rawUrl);\n\n          /** @type {?} */\n          _this42.routerState = state;\n\n          if (_this42.urlUpdateStrategy === 'deferred' && !skipLocationChange) {\n            _this42.setBrowserUrl(_this42.rawUrlTree, replaceUrl, id);\n          }\n\n          new ActivateRoutes(_this42.routeReuseStrategy, state, storedState, function (evt) {\n            return _this42.triggerEvent(evt);\n          }).activate(_this42.rootContexts);\n          navigationIsSuccessful = true;\n        }).then(function () {\n          if (navigationIsSuccessful) {\n            _this42.navigated = true;\n            _this42.lastSuccessfulId = id;\n\n            /** @type {?} */\n            _this42.events.next(new NavigationEnd(id, _this42.serializeUrl(url), _this42.serializeUrl(_this42.currentUrlTree)));\n\n            resolvePromise(true);\n          } else {\n            _this42.resetUrlToCurrentUrlTree();\n\n            /** @type {?} */\n            _this42.events.next(new NavigationCancel(id, _this42.serializeUrl(url), ''));\n\n            resolvePromise(false);\n          }\n        }, function (e) {\n          if (isNavigationCancelingError(e)) {\n            _this42.navigated = true;\n\n            _this42.resetStateAndUrl(storedState, storedUrl, rawUrl);\n\n            /** @type {?} */\n            _this42.events.next(new NavigationCancel(id, _this42.serializeUrl(url), e.message));\n\n            resolvePromise(false);\n          } else {\n            _this42.resetStateAndUrl(storedState, storedUrl, rawUrl);\n\n            /** @type {?} */\n            _this42.events.next(new NavigationError(id, _this42.serializeUrl(url), e));\n\n            try {\n              resolvePromise(_this42.errorHandler(e));\n            } catch (ee) {\n              rejectPromise(ee);\n            }\n          }\n        });\n      }\n      /**\n       * @param {?} url\n       * @param {?} replaceUrl\n       * @param {?} id\n       * @return {?}\n       */\n\n    }, {\n      key: \"setBrowserUrl\",\n      value: function setBrowserUrl(url, replaceUrl, id) {\n        /** @type {?} */\n        var path = this.urlSerializer.serialize(url);\n\n        if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {\n          this.location.replaceState(path, '', {\n            navigationId: id\n          });\n        } else {\n          this.location.go(path, '', {\n            navigationId: id\n          });\n        }\n      }\n      /**\n       * @param {?} storedState\n       * @param {?} storedUrl\n       * @param {?} rawUrl\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetStateAndUrl\",\n      value: function resetStateAndUrl(storedState, storedUrl, rawUrl) {\n        /** @type {?} */\n        this.routerState = storedState;\n        this.currentUrlTree = storedUrl;\n        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);\n        this.resetUrlToCurrentUrlTree();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"resetUrlToCurrentUrlTree\",\n      value: function resetUrlToCurrentUrlTree() {\n        this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), '', {\n          navigationId: this.lastSuccessfulId\n        });\n      }\n    }]);\n\n    return Router;\n  }();\n\n  Router.ɵfac = function Router_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  Router.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Router\n  });\n  return Router;\n})();\n\nvar ActivateRoutes = /*#__PURE__*/function () {\n  /**\n   * @param {?} routeReuseStrategy\n   * @param {?} futureState\n   * @param {?} currState\n   * @param {?} forwardEvent\n   */\n  function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {\n    _classCallCheck(this, ActivateRoutes);\n\n    this.routeReuseStrategy = routeReuseStrategy;\n    this.futureState = futureState;\n    this.currState = currState;\n    this.forwardEvent = forwardEvent;\n  }\n  /**\n   * @param {?} parentContexts\n   * @return {?}\n   */\n\n\n  _createClass(ActivateRoutes, [{\n    key: \"activate\",\n    value: function activate(parentContexts) {\n      /** @type {?} */\n      var futureRoot = this.futureState._root;\n      /** @type {?} */\n\n      var currRoot = this.currState ? this.currState._root : null;\n      this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n      advanceActivatedRoute(this.futureState.root);\n      this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n    }\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateChildRoutes\",\n    value: function deactivateChildRoutes(futureNode, currNode, contexts) {\n      var _this43 = this;\n\n      /** @type {?} */\n      var children = nodeChildrenAsMap(currNode); // Recurse on the routes active in the future state to de-activate deeper children\n\n      futureNode.children.forEach(function (futureChild) {\n        /** @type {?} */\n        var childOutletName = futureChild.value.outlet;\n\n        _this43.deactivateRoutes(futureChild, children[childOutletName], contexts);\n\n        delete children[childOutletName];\n      }); // De-activate the routes that will not be re-used\n\n      forEach(children, function (v, childName) {\n        _this43.deactivateRouteAndItsChildren(v, contexts);\n      });\n    }\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContext\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRoutes\",\n    value: function deactivateRoutes(futureNode, currNode, parentContext) {\n      /** @type {?} */\n      var future = futureNode.value;\n      /** @type {?} */\n\n      var curr = currNode ? currNode.value : null;\n\n      if (future === curr) {\n        // Reusing the node, check to see if the children need to be de-activated\n        if (future.component) {\n          /** @type {?} */\n          var context = parentContext.getContext(future.outlet);\n\n          if (context) {\n            this.deactivateChildRoutes(futureNode, currNode, context.children);\n          }\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.deactivateChildRoutes(futureNode, currNode, parentContext);\n        }\n      } else {\n        if (curr) {\n          // Deactivate the current route which will not be re-used\n          this.deactivateRouteAndItsChildren(currNode, parentContext);\n        }\n      }\n    }\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRouteAndItsChildren\",\n    value: function deactivateRouteAndItsChildren(route, parentContexts) {\n      if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n        this.detachAndStoreRouteSubtree(route, parentContexts);\n      } else {\n        this.deactivateRouteAndOutlet(route, parentContexts);\n      }\n    }\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"detachAndStoreRouteSubtree\",\n    value: function detachAndStoreRouteSubtree(route, parentContexts) {\n      /** @type {?} */\n      var context = parentContexts.getContext(route.value.outlet);\n\n      if (context && context.outlet) {\n        /** @type {?} */\n        var componentRef = context.outlet.detach();\n        /** @type {?} */\n\n        var contexts = context.children.onOutletDeactivated();\n        this.routeReuseStrategy.store(route.value.snapshot, {\n          componentRef: componentRef,\n          route: route,\n          contexts: contexts\n        });\n      }\n    }\n    /**\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRouteAndOutlet\",\n    value: function deactivateRouteAndOutlet(route, parentContexts) {\n      var _this44 = this;\n\n      /** @type {?} */\n      var context = parentContexts.getContext(route.value.outlet);\n\n      if (context) {\n        /** @type {?} */\n        var children = nodeChildrenAsMap(route);\n        /** @type {?} */\n\n        var contexts = route.value.component ? context.children : parentContexts;\n        forEach(children, function (v, k) {\n          return _this44.deactivateRouteAndItsChildren(v, contexts);\n        });\n\n        if (context.outlet) {\n          // Destroy the component\n          context.outlet.deactivate(); // Destroy the contexts for all the outlets that were in the component\n\n          context.children.onOutletDeactivated();\n        }\n      }\n    }\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"activateChildRoutes\",\n    value: function activateChildRoutes(futureNode, currNode, contexts) {\n      var _this45 = this;\n\n      /** @type {?} */\n      var children = nodeChildrenAsMap(currNode);\n      futureNode.children.forEach(function (c) {\n        _this45.activateRoutes(c, children[c.value.outlet], contexts);\n\n        _this45.forwardEvent(new ActivationEnd(c.value.snapshot));\n      });\n\n      if (futureNode.children.length) {\n        this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n      }\n    }\n    /**\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"activateRoutes\",\n    value: function activateRoutes(futureNode, currNode, parentContexts) {\n      /** @type {?} */\n      var future = futureNode.value;\n      /** @type {?} */\n\n      var curr = currNode ? currNode.value : null;\n      advanceActivatedRoute(future); // reusing the node\n\n      if (future === curr) {\n        if (future.component) {\n          /** @type {?} */\n          var context = parentContexts.getOrCreateContext(future.outlet);\n          this.activateChildRoutes(futureNode, currNode, context.children);\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.activateChildRoutes(futureNode, currNode, parentContexts);\n        }\n      } else {\n        if (future.component) {\n          /** @type {?} */\n          var _context = parentContexts.getOrCreateContext(future.outlet);\n\n          if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n            /** @type {?} */\n            var stored =\n            /** @type {?} */\n            this.routeReuseStrategy.retrieve(future.snapshot);\n            this.routeReuseStrategy.store(future.snapshot, null);\n\n            _context.children.onOutletReAttached(stored.contexts);\n\n            _context.attachRef = stored.componentRef;\n            _context.route = stored.route.value;\n\n            if (_context.outlet) {\n              // Attach right away when the outlet has already been instantiated\n              // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n              _context.outlet.attach(stored.componentRef, stored.route.value);\n            }\n\n            advanceActivatedRouteNodeAndItsChildren(stored.route);\n          } else {\n            /** @type {?} */\n            var config = parentLoadedConfig(future.snapshot);\n            /** @type {?} */\n\n            var cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\n            _context.attachRef = null;\n            _context.route = future;\n            _context.resolver = cmpFactoryResolver;\n\n            if (_context.outlet) {\n              // Activate the outlet when it has already been instantiated\n              // Otherwise it will get activated from its `ngOnInit` when instantiated\n              _context.outlet.activateWith(future, cmpFactoryResolver);\n            }\n\n            this.activateChildRoutes(futureNode, null, _context.children);\n          }\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.activateChildRoutes(futureNode, null, parentContexts);\n        }\n      }\n    }\n  }]);\n\n  return ActivateRoutes;\n}();\n/**\n * @param {?} node\n * @return {?}\n */\n\n\nfunction advanceActivatedRouteNodeAndItsChildren(node) {\n  advanceActivatedRoute(node.value);\n  node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n}\n/**\n * @param {?} snapshot\n * @return {?}\n */\n\n\nfunction parentLoadedConfig(snapshot) {\n  for (var s = snapshot.parent; s; s = s.parent) {\n    /** @type {?} */\n    var route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n    if (route && route.component) return null;\n  }\n\n  return null;\n}\n/**\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction validateCommands(commands) {\n  for (var i = 0; i < commands.length; i++) {\n    /** @type {?} */\n    var cmd = commands[i];\n\n    if (cmd == null) {\n      throw new Error(\"The requested path contains \".concat(cmd, \" segment at index \").concat(i));\n    }\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Lets you link to specific routes in your app.\n *\n * Consider the following route configuration:\n * `[{ path: 'user/:name', component: UserCmp }]`.\n * When linking to this `user/:name` route, you use the `RouterLink` directive.\n *\n * If the link is static, you can use the directive as follows:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * If you use dynamic values to generate the link, you can pass an array of path\n * segments, followed by the params for each segment.\n *\n * For instance `['/team', teamId, 'user', userName, {details: true}]`\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one\n * (e.g., `['/team/11/user', userName, {details: true}]`).\n *\n * The first segment name can be prepended with `/`, `./`, or `../`:\n * * If the first segment begins with `/`, the router will look up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n *   instead look in the children of the current activated route.\n * * And if the first segment begins with `../`, the router will go up one level.\n *\n * You can set query params and fragment as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n *\n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\n * directive to preserve the current query params and fragment:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n *   link to user component\n * </a>\n * ```\n *\n * You can tell the directive to how to handle queryParams, available options are:\n *  - `'merge'`: merge the queryParams into the current queryParams\n *  - `'preserve'`: preserve the current queryParams\n *  - default/`''`: use the queryParams only\n *\n * Same options for {\\@link NavigationExtras#queryParamsHandling\n * NavigationExtras#queryParamsHandling}.\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * The router link directive always treats the provided input as a delta to the current url.\n *\n * For instance, if the current url is `/user/(box//aux:team)`.\n *\n * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n * `/user/(jim//aux:team)`.\n *\n * See {\\@link Router#createUrlTree createUrlTree} for more information.\n *\n * \\@ngModule RouterModule\n *\n *\n */\n\n\nvar RouterLink = /*#__PURE__*/(function () {\n  var RouterLink = /*#__PURE__*/function () {\n    /**\n     * @param {?} router\n     * @param {?} route\n     * @param {?} tabIndex\n     * @param {?} renderer\n     * @param {?} el\n     */\n    function RouterLink(router, route, tabIndex, renderer, el) {\n      _classCallCheck(this, RouterLink);\n\n      this.router = router;\n      this.route = route;\n      this.commands = [];\n\n      if (tabIndex == null) {\n        renderer.setAttribute(el.nativeElement, 'tabindex', '0');\n      }\n    }\n    /**\n     * @param {?} commands\n     * @return {?}\n     */\n\n\n    _createClass(RouterLink, [{\n      key: \"routerLink\",\n      set: function set(commands) {\n        if (commands != null) {\n          this.commands = Array.isArray(commands) ? commands : [commands];\n        } else {\n          this.commands = [];\n        }\n      }\n      /**\n       * @deprecated 4.0.0 use `queryParamsHandling` instead.\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"preserveQueryParams\",\n      set: function set(value) {\n        if (isDevMode() &&\n        /** @type {?} */\n        console &&\n        /** @type {?} */\n        console.warn) {\n          console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');\n        }\n\n        this.preserve = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick() {\n        /** @type {?} */\n        var extras = {\n          skipLocationChange: attrBoolValue(this.skipLocationChange),\n          replaceUrl: attrBoolValue(this.replaceUrl)\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return true;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"urlTree\",\n      get: function get() {\n        return this.router.createUrlTree(this.commands, {\n          relativeTo: this.route,\n          queryParams: this.queryParams,\n          fragment: this.fragment,\n          preserveQueryParams: attrBoolValue(this.preserve),\n          queryParamsHandling: this.queryParamsHandling,\n          preserveFragment: attrBoolValue(this.preserveFragment)\n        });\n      }\n    }]);\n\n    return RouterLink;\n  }();\n\n  RouterLink.ɵfac = function RouterLink_Factory(t) {\n    return new (t || RouterLink)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ActivatedRoute), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  RouterLink.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterLink,\n    selectors: [[\"\", \"routerLink\", \"\", 5, \"a\"]],\n    hostBindings: function RouterLink_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function RouterLink_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      routerLink: \"routerLink\",\n      preserveQueryParams: \"preserveQueryParams\",\n      queryParams: \"queryParams\",\n      fragment: \"fragment\",\n      queryParamsHandling: \"queryParamsHandling\",\n      preserveFragment: \"preserveFragment\",\n      skipLocationChange: \"skipLocationChange\",\n      replaceUrl: \"replaceUrl\"\n    }\n  });\n  /** @nocollapse */\n\n  return RouterLink;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * \\@description\n *\n * Lets you link to specific routes in your app.\n *\n * See `RouterLink` for more information.\n *\n * \\@ngModule RouterModule\n *\n *\n */\n\n\nvar RouterLinkWithHref = /*#__PURE__*/(function () {\n  var RouterLinkWithHref = /*#__PURE__*/function () {\n    /**\n     * @param {?} router\n     * @param {?} route\n     * @param {?} locationStrategy\n     */\n    function RouterLinkWithHref(router, route, locationStrategy) {\n      var _this46 = this;\n\n      _classCallCheck(this, RouterLinkWithHref);\n\n      this.router = router;\n      this.route = route;\n      this.locationStrategy = locationStrategy;\n      this.commands = [];\n      this.subscription = router.events.subscribe(function (s) {\n        if (s instanceof NavigationEnd) {\n          _this46.updateTargetUrlAndHref();\n        }\n      });\n    }\n    /**\n     * @param {?} commands\n     * @return {?}\n     */\n\n\n    _createClass(RouterLinkWithHref, [{\n      key: \"routerLink\",\n      set: function set(commands) {\n        if (commands != null) {\n          this.commands = Array.isArray(commands) ? commands : [commands];\n        } else {\n          this.commands = [];\n        }\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"preserveQueryParams\",\n      set: function set(value) {\n        if (isDevMode() &&\n        /** @type {?} */\n        console &&\n        /** @type {?} */\n        console.warn) {\n          console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n        }\n\n        this.preserve = value;\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.updateTargetUrlAndHref();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.subscription.unsubscribe();\n      }\n      /**\n       * @param {?} button\n       * @param {?} ctrlKey\n       * @param {?} metaKey\n       * @param {?} shiftKey\n       * @return {?}\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick(button, ctrlKey, metaKey, shiftKey) {\n        if (button !== 0 || ctrlKey || metaKey || shiftKey) {\n          return true;\n        }\n\n        if (typeof this.target === 'string' && this.target != '_self') {\n          return true;\n        }\n        /** @type {?} */\n\n\n        var extras = {\n          skipLocationChange: attrBoolValue(this.skipLocationChange),\n          replaceUrl: attrBoolValue(this.replaceUrl)\n        };\n        this.router.navigateByUrl(this.urlTree, extras);\n        return false;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateTargetUrlAndHref\",\n      value: function updateTargetUrlAndHref() {\n        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"urlTree\",\n      get: function get() {\n        return this.router.createUrlTree(this.commands, {\n          relativeTo: this.route,\n          queryParams: this.queryParams,\n          fragment: this.fragment,\n          preserveQueryParams: attrBoolValue(this.preserve),\n          queryParamsHandling: this.queryParamsHandling,\n          preserveFragment: attrBoolValue(this.preserveFragment)\n        });\n      }\n    }]);\n\n    return RouterLinkWithHref;\n  }();\n\n  RouterLinkWithHref.ɵfac = function RouterLinkWithHref_Factory(t) {\n    return new (t || RouterLinkWithHref)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocationStrategy));\n  };\n\n  RouterLinkWithHref.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterLinkWithHref,\n    selectors: [[\"a\", \"routerLink\", \"\"]],\n    hostVars: 2,\n    hostBindings: function RouterLinkWithHref_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function RouterLinkWithHref_click_HostBindingHandler($event) {\n          return ctx.onClick($event.button, $event.ctrlKey, $event.metaKey, $event.shiftKey);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"href\", ctx.href, ɵngcc0.ɵɵsanitizeUrl);\n        ɵngcc0.ɵɵattribute(\"target\", ctx.target);\n      }\n    },\n    inputs: {\n      routerLink: \"routerLink\",\n      preserveQueryParams: \"preserveQueryParams\",\n      target: \"target\",\n      queryParams: \"queryParams\",\n      fragment: \"fragment\",\n      queryParamsHandling: \"queryParamsHandling\",\n      preserveFragment: \"preserveFragment\",\n      skipLocationChange: \"skipLocationChange\",\n      replaceUrl: \"replaceUrl\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return RouterLinkWithHref;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction attrBoolValue(s) {\n  return s === '' || !!s;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n *\n * \\@description\n *\n * Lets you add a CSS class to an element when the link's route becomes active.\n *\n * This directive lets you add a CSS class to an element when the link's route\n * becomes active.\n *\n * Consider the following example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * When the url is either '/user' or '/user/bob', the active-link class will\n * be added to the `a` tag. If the url changes, the class will be removed.\n *\n * You can set more than one class, as follows:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n * only when the url matches the link exactly.\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * You can assign the RouterLinkActive instance to a template variable and directly check\n * the `isActive` status.\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * This will set the active-link class on the div tag if the url is either '/user/jim' or\n * '/user/bob'.\n *\n * \\@ngModule RouterModule\n *\n *\n */\n\n\nvar RouterLinkActive = /*#__PURE__*/(function () {\n  var RouterLinkActive = /*#__PURE__*/function () {\n    /**\n     * @param {?} router\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?} cdr\n     */\n    function RouterLinkActive(router, element, renderer, cdr) {\n      var _this47 = this;\n\n      _classCallCheck(this, RouterLinkActive);\n\n      this.router = router;\n      this.element = element;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.classes = [];\n      this.isActive = false;\n      this.routerLinkActiveOptions = {\n        exact: false\n      };\n      this.subscription = router.events.subscribe(function (s) {\n        if (s instanceof NavigationEnd) {\n          _this47.update();\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(RouterLinkActive, [{\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        var _this48 = this;\n\n        this.links.changes.subscribe(function (_) {\n          return _this48.update();\n        });\n        this.linksWithHrefs.changes.subscribe(function (_) {\n          return _this48.update();\n        });\n        this.update();\n      }\n      /**\n       * @param {?} data\n       * @return {?}\n       */\n\n    }, {\n      key: \"routerLinkActive\",\n      set: function set(data) {\n        /** @type {?} */\n        var classes = Array.isArray(data) ? data : data.split(' ');\n        this.classes = classes.filter(function (c) {\n          return !!c;\n        });\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.update();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.subscription.unsubscribe();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"update\",\n      value: function update() {\n        var _this49 = this;\n\n        if (!this.links || !this.linksWithHrefs || !this.router.navigated) return;\n        Promise.resolve().then(function () {\n          /** @type {?} */\n          var hasActiveLinks = _this49.hasActiveLinks();\n\n          if (_this49.isActive !== hasActiveLinks) {\n            /** @type {?} */\n            _this49.isActive = hasActiveLinks;\n\n            _this49.classes.forEach(function (c) {\n              if (hasActiveLinks) {\n                _this49.renderer.addClass(_this49.element.nativeElement, c);\n              } else {\n                _this49.renderer.removeClass(_this49.element.nativeElement, c);\n              }\n            });\n          }\n        });\n      }\n      /**\n       * @param {?} router\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLinkActive\",\n      value: function isLinkActive(router) {\n        var _this50 = this;\n\n        return function (link) {\n          return router.isActive(link.urlTree, _this50.routerLinkActiveOptions.exact);\n        };\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasActiveLinks\",\n      value: function hasActiveLinks() {\n        return this.links.some(this.isLinkActive(this.router)) || this.linksWithHrefs.some(this.isLinkActive(this.router));\n      }\n    }]);\n\n    return RouterLinkActive;\n  }();\n\n  RouterLinkActive.ɵfac = function RouterLinkActive_Factory(t) {\n    return new (t || RouterLinkActive)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  RouterLinkActive.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterLinkActive,\n    selectors: [[\"\", \"routerLinkActive\", \"\"]],\n    contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLink, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLinkWithHref, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.links = _t);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linksWithHrefs = _t);\n      }\n    },\n    inputs: {\n      routerLinkActiveOptions: \"routerLinkActiveOptions\",\n      routerLinkActive: \"routerLinkActive\"\n    },\n    exportAs: [\"routerLinkActive\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return RouterLinkActive;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n *\n */\n\n\nvar OutletContext = /*#__PURE__*/_createClass(function OutletContext() {\n  _classCallCheck(this, OutletContext);\n\n  this.outlet = null;\n  this.route = null;\n  this.resolver = null;\n  this.children = new ChildrenOutletContexts();\n  this.attachRef = null;\n});\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n *\n */\n\n\nvar ChildrenOutletContexts = /*#__PURE__*/function () {\n  function ChildrenOutletContexts() {\n    _classCallCheck(this, ChildrenOutletContexts);\n\n    this.contexts = new Map();\n  }\n  /**\n   * Called when a `RouterOutlet` directive is instantiated\n   * @param {?} childName\n   * @param {?} outlet\n   * @return {?}\n   */\n\n\n  _createClass(ChildrenOutletContexts, [{\n    key: \"onChildOutletCreated\",\n    value: function onChildOutletCreated(childName, outlet) {\n      /** @type {?} */\n      var context = this.getOrCreateContext(childName);\n      context.outlet = outlet;\n      this.contexts.set(childName, context);\n    }\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     * @param {?} childName\n     * @return {?}\n     */\n\n  }, {\n    key: \"onChildOutletDestroyed\",\n    value: function onChildOutletDestroyed(childName) {\n      /** @type {?} */\n      var context = this.getContext(childName);\n\n      if (context) {\n        context.outlet = null;\n      }\n    }\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     * @return {?}\n     */\n\n  }, {\n    key: \"onOutletDeactivated\",\n    value: function onOutletDeactivated() {\n      /** @type {?} */\n      var contexts = this.contexts;\n      this.contexts = new Map();\n      return contexts;\n    }\n    /**\n     * @param {?} contexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"onOutletReAttached\",\n    value: function onOutletReAttached(contexts) {\n      this.contexts = contexts;\n    }\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n\n  }, {\n    key: \"getOrCreateContext\",\n    value: function getOrCreateContext(childName) {\n      /** @type {?} */\n      var context = this.getContext(childName);\n\n      if (!context) {\n        context = new OutletContext();\n        this.contexts.set(childName, context);\n      }\n\n      return context;\n    }\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n\n  }, {\n    key: \"getContext\",\n    value: function getContext(childName) {\n      return this.contexts.get(childName) || null;\n    }\n  }]);\n\n  return ChildrenOutletContexts;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * A router outlet will emit an activate event any time a new component is being instantiated,\n * and a deactivate event when it is being destroyed.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n * \\@ngModule RouterModule\n *\n *\n */\n\n\nvar RouterOutlet = /*#__PURE__*/(function () {\n  var RouterOutlet = /*#__PURE__*/function () {\n    /**\n     * @param {?} parentContexts\n     * @param {?} location\n     * @param {?} resolver\n     * @param {?} name\n     * @param {?} changeDetector\n     */\n    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {\n      _classCallCheck(this, RouterOutlet);\n\n      this.parentContexts = parentContexts;\n      this.location = location;\n      this.resolver = resolver;\n      this.changeDetector = changeDetector;\n      this.activated = null;\n      this._activatedRoute = null;\n      this.activateEvents = new EventEmitter();\n      this.deactivateEvents = new EventEmitter();\n      this.name = name || PRIMARY_OUTLET;\n      parentContexts.onChildOutletCreated(this.name, this);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(RouterOutlet, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.parentContexts.onChildOutletDestroyed(this.name);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        if (!this.activated) {\n          /** @type {?} */\n          var context = this.parentContexts.getContext(this.name);\n\n          if (context && context.route) {\n            if (context.attachRef) {\n              // `attachRef` is populated when there is an existing component to mount\n              this.attach(context.attachRef, context.route);\n            } else {\n              // otherwise the component defined in the configuration is created\n              this.activateWith(context.route, context.resolver || null);\n            }\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isActivated\",\n      get: function get() {\n        return !!this.activated;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"component\",\n      get: function get() {\n        if (!this.activated) throw new Error('Outlet is not activated');\n        return this.activated.instance;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"activatedRoute\",\n      get: function get() {\n        if (!this.activated) throw new Error('Outlet is not activated');\n        return (\n          /** @type {?} */\n          this._activatedRoute\n        );\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"activatedRouteData\",\n      get: function get() {\n        if (this._activatedRoute) {\n          return this._activatedRoute.snapshot.data;\n        }\n\n        return {};\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to detach the subtree\n       * @return {?}\n       */\n\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        if (!this.activated) throw new Error('Outlet is not activated');\n        this.location.detach();\n        /** @type {?} */\n\n        var cmp = this.activated;\n        this.activated = null;\n        this._activatedRoute = null;\n        return cmp;\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n       * @param {?} ref\n       * @param {?} activatedRoute\n       * @return {?}\n       */\n\n    }, {\n      key: \"attach\",\n      value: function attach(ref, activatedRoute) {\n        this.activated = ref;\n        this._activatedRoute = activatedRoute;\n        this.location.insert(ref.hostView);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"deactivate\",\n      value: function deactivate() {\n        if (this.activated) {\n          /** @type {?} */\n          var c = this.component;\n          this.activated.destroy();\n          this.activated = null;\n          this._activatedRoute = null;\n          this.deactivateEvents.emit(c);\n        }\n      }\n      /**\n       * @param {?} activatedRoute\n       * @param {?} resolver\n       * @return {?}\n       */\n\n    }, {\n      key: \"activateWith\",\n      value: function activateWith(activatedRoute, resolver) {\n        if (this.isActivated) {\n          throw new Error('Cannot activate an already activated outlet');\n        }\n\n        this._activatedRoute = activatedRoute;\n        /** @type {?} */\n\n        var snapshot = activatedRoute._futureSnapshot;\n        /** @type {?} */\n\n        var component =\n        /** @type {?} */\n\n        /** @type {?} */\n        snapshot.routeConfig.component;\n        resolver = resolver || this.resolver;\n        /** @type {?} */\n\n        var factory = resolver.resolveComponentFactory(component);\n        /** @type {?} */\n\n        var childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        /** @type {?} */\n\n        var injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);\n        this.activated = this.location.createComponent(factory, this.location.length, injector); // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n\n        this.changeDetector.markForCheck();\n        this.activateEvents.emit(this.activated.instance);\n      }\n    }]);\n\n    return RouterOutlet;\n  }();\n\n  RouterOutlet.ɵfac = function RouterOutlet_Factory(t) {\n    return new (t || RouterOutlet)(ɵngcc0.ɵɵdirectiveInject(ChildrenOutletContexts), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinjectAttribute('name'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  RouterOutlet.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterOutlet,\n    selectors: [[\"router-outlet\"]],\n    outputs: {\n      activateEvents: \"activate\",\n      deactivateEvents: \"deactivate\"\n    },\n    exportAs: [\"outlet\"]\n  });\n  /** @nocollapse */\n\n  return RouterOutlet;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar OutletInjector = /*#__PURE__*/function () {\n  /**\n   * @param {?} route\n   * @param {?} childContexts\n   * @param {?} parent\n   */\n  function OutletInjector(route, childContexts, parent) {\n    _classCallCheck(this, OutletInjector);\n\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n  /**\n   * @param {?} token\n   * @param {?=} notFoundValue\n   * @return {?}\n   */\n\n\n  _createClass(OutletInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      if (token === ActivatedRoute) {\n        return this.route;\n      }\n\n      if (token === ChildrenOutletContexts) {\n        return this.childContexts;\n      }\n\n      return this.parent.get(token, notFoundValue);\n    }\n  }]);\n\n  return OutletInjector;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Provides a preloading strategy.\n *\n * \\@experimental\n * @abstract\n */\n\n\nvar PreloadingStrategy = /*#__PURE__*/_createClass(function PreloadingStrategy() {\n  _classCallCheck(this, PreloadingStrategy);\n});\n/**\n * \\@description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * \\@experimental\n */\n\n\nvar PreloadAllModules = /*#__PURE__*/function () {\n  function PreloadAllModules() {\n    _classCallCheck(this, PreloadAllModules);\n  }\n\n  _createClass(PreloadAllModules, [{\n    key: \"preload\",\n    value:\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function preload(route, fn) {\n      return fn().pipe(catchError(function () {\n        return of(null);\n      }));\n    }\n  }]);\n\n  return PreloadAllModules;\n}();\n/**\n * \\@description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * \\@experimental\n */\n\n\nvar NoPreloading = /*#__PURE__*/function () {\n  function NoPreloading() {\n    _classCallCheck(this, NoPreloading);\n  }\n\n  _createClass(NoPreloading, [{\n    key: \"preload\",\n    value:\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function preload(route, fn) {\n      return of(null);\n    }\n  }]);\n\n  return NoPreloading;\n}();\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n *\n */\n\n\nvar RouterPreloader = /*#__PURE__*/(function () {\n  var RouterPreloader = /*#__PURE__*/function () {\n    /**\n     * @param {?} router\n     * @param {?} moduleLoader\n     * @param {?} compiler\n     * @param {?} injector\n     * @param {?} preloadingStrategy\n     */\n    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n      _classCallCheck(this, RouterPreloader);\n\n      this.router = router;\n      this.injector = injector;\n      this.preloadingStrategy = preloadingStrategy;\n      /** @type {?} */\n\n      var onStartLoad = function onStartLoad(r) {\n        return router.triggerEvent(new RouteConfigLoadStart(r));\n      };\n      /** @type {?} */\n\n\n      var onEndLoad = function onEndLoad(r) {\n        return router.triggerEvent(new RouteConfigLoadEnd(r));\n      };\n\n      this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(RouterPreloader, [{\n      key: \"setUpPreloading\",\n      value: function setUpPreloading() {\n        var _this51 = this;\n\n        this.subscription = this.router.events.pipe(filter(function (e) {\n          return e instanceof NavigationEnd;\n        }), concatMap(function () {\n          return _this51.preload();\n        })).subscribe(function () {});\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"preload\",\n      value: function preload() {\n        /** @type {?} */\n        var ngModule = this.injector.get(NgModuleRef);\n        return this.processRoutes(ngModule, this.router.config);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.subscription.unsubscribe();\n      }\n      /**\n       * @param {?} ngModule\n       * @param {?} routes\n       * @return {?}\n       */\n\n    }, {\n      key: \"processRoutes\",\n      value: function processRoutes(ngModule, routes) {\n        /** @type {?} */\n        var res = [];\n\n        var _iterator10 = _createForOfIteratorHelper(routes),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var route = _step10.value;\n\n            // we already have the config loaded, just recurse\n            if (route.loadChildren && !route.canLoad && route._loadedConfig) {\n              /** @type {?} */\n              var childConfig = route._loadedConfig;\n              res.push(this.processRoutes(childConfig.module, childConfig.routes)); // no config loaded, fetch the config\n            } else if (route.loadChildren && !route.canLoad) {\n              res.push(this.preloadConfig(ngModule, route)); // recurse into children\n            } else if (route.children) {\n              res.push(this.processRoutes(ngModule, route.children));\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        return from(res).pipe(mergeAll(), map(function (_) {\n          return void 0;\n        }));\n      }\n      /**\n       * @param {?} ngModule\n       * @param {?} route\n       * @return {?}\n       */\n\n    }, {\n      key: \"preloadConfig\",\n      value: function preloadConfig(ngModule, route) {\n        var _this52 = this;\n\n        return this.preloadingStrategy.preload(route, function () {\n          /** @type {?} */\n          var loaded$ = _this52.loader.load(ngModule.injector, route);\n\n          return loaded$.pipe(mergeMap(function (config) {\n            route._loadedConfig = config;\n            return _this52.processRoutes(config.module, config.routes);\n          }));\n        });\n      }\n    }]);\n\n    return RouterPreloader;\n  }();\n\n  RouterPreloader.ɵfac = function RouterPreloader_Factory(t) {\n    return new (t || RouterPreloader)(ɵngcc0.ɵɵinject(Router), ɵngcc0.ɵɵinject(NgModuleFactoryLoader), ɵngcc0.ɵɵinject(ɵngcc0.Compiler), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(PreloadingStrategy));\n  };\n\n  RouterPreloader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: RouterPreloader,\n    factory: RouterPreloader.ɵfac\n  });\n  /** @nocollapse */\n\n  return RouterPreloader;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nvar RouterScroller = /*#__PURE__*/(function () {\n  var RouterScroller = /*#__PURE__*/function () {\n    /**\n     * @param {?} router\n     * @param {?} viewportScroller\n     * @param {?=} options\n     */\n    function RouterScroller(router, viewportScroller) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      _classCallCheck(this, RouterScroller);\n\n      this.router = router;\n      this.viewportScroller = viewportScroller;\n      this.options = options;\n      this.lastId = 0;\n      this.lastSource = 'imperative';\n      this.restoredId = 0;\n      this.store = {}; // Default both options to 'disabled'\n\n      options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';\n      options.anchorScrolling = options.anchorScrolling || 'disabled';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(RouterScroller, [{\n      key: \"init\",\n      value: function init() {\n        // we want to disable the automatic scrolling because having two places\n        // responsible for scrolling results race conditions, especially given\n        // that browser don't implement this behavior consistently\n        if (this.options.scrollPositionRestoration !== 'disabled') {\n          this.viewportScroller.setHistoryScrollRestoration('manual');\n        }\n\n        this.routerEventsSubscription = this.createScrollEvents();\n        this.scrollEventsSubscription = this.consumeScrollEvents();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"createScrollEvents\",\n      value: function createScrollEvents() {\n        var _this53 = this;\n\n        return this.router.events.subscribe(function (e) {\n          if (e instanceof NavigationStart) {\n            // store the scroll position of the current stable navigations.\n            _this53.store[_this53.lastId] = _this53.viewportScroller.getScrollPosition();\n            _this53.lastSource = e.navigationTrigger;\n            _this53.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n          } else if (e instanceof NavigationEnd) {\n            _this53.lastId = e.id;\n\n            _this53.scheduleScrollEvent(e, _this53.router.parseUrl(e.urlAfterRedirects).fragment);\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"consumeScrollEvents\",\n      value: function consumeScrollEvents() {\n        var _this54 = this;\n\n        return this.router.events.subscribe(function (e) {\n          if (!(e instanceof Scroll)) return; // a popstate event. The pop state event will always ignore anchor scrolling.\n\n          if (e.position) {\n            if (_this54.options.scrollPositionRestoration === 'top') {\n              _this54.viewportScroller.scrollToPosition([0, 0]);\n            } else if (_this54.options.scrollPositionRestoration === 'enabled') {\n              _this54.viewportScroller.scrollToPosition(e.position);\n            } // imperative navigation \"forward\"\n\n          } else {\n            if (e.anchor && _this54.options.anchorScrolling === 'enabled') {\n              _this54.viewportScroller.scrollToAnchor(e.anchor);\n            } else if (_this54.options.scrollPositionRestoration !== 'disabled') {\n              _this54.viewportScroller.scrollToPosition([0, 0]);\n            }\n          }\n        });\n      }\n      /**\n       * @param {?} routerEvent\n       * @param {?} anchor\n       * @return {?}\n       */\n\n    }, {\n      key: \"scheduleScrollEvent\",\n      value: function scheduleScrollEvent(routerEvent, anchor) {\n        this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.routerEventsSubscription) {\n          this.routerEventsSubscription.unsubscribe();\n        }\n\n        if (this.scrollEventsSubscription) {\n          this.scrollEventsSubscription.unsubscribe();\n        }\n      }\n    }]);\n\n    return RouterScroller;\n  }();\n\n  RouterScroller.ɵfac = function RouterScroller_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  RouterScroller.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterScroller\n  });\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n   */\n\n  /** *\n   * \\@description\n   *\n   * Contains a list of directives\n   *\n   *\n    @type {?} */\n\n  return RouterScroller;\n})();\nvar ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, EmptyOutletComponent];\n/** *\n * \\@description\n *\n * Is used in DI to configure the router.\n *\n *\n  @type {?} */\n\nvar ROUTER_CONFIGURATION = /*#__PURE__*/new InjectionToken('ROUTER_CONFIGURATION');\n/** *\n * \\@docsNotRequired\n  @type {?} */\n\nvar ROUTER_FORROOT_GUARD = /*#__PURE__*/new InjectionToken('ROUTER_FORROOT_GUARD');\n/** @type {?} */\n\nvar ROUTER_PROVIDERS = [Location, {\n  provide: UrlSerializer,\n  useClass: DefaultUrlSerializer\n}, {\n  provide: Router,\n  useFactory: setupRouter,\n  deps: [ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector, NgModuleFactoryLoader, Compiler, ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, /*#__PURE__*/new Optional()], [RouteReuseStrategy, /*#__PURE__*/new Optional()]]\n}, ChildrenOutletContexts, {\n  provide: ActivatedRoute,\n  useFactory: rootRoute,\n  deps: [Router]\n}, {\n  provide: NgModuleFactoryLoader,\n  useClass: SystemJsNgModuleLoader\n}, RouterPreloader, NoPreloading, PreloadAllModules, {\n  provide: ROUTER_CONFIGURATION,\n  useValue: {\n    enableTracing: false\n  }\n}];\n/**\n * @return {?}\n */\n\nfunction routerNgProbeToken() {\n  return new NgProbeToken('Router', Router);\n}\n/**\n * \\@usageNotes\n *\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n *\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n *\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n *\n * When registered at the root, the module should be used as follows\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * For submodules and lazy loaded submodules the module should be used as follows:\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@description\n *\n * Adds router directives and providers.\n *\n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n *\n * The Angular router solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n *\n * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n * overview of how the router should be used.\n *\n *\n */\n\n\nvar RouterModule = /*#__PURE__*/(function () {\n  var RouterModule = /*#__PURE__*/function () {\n    /**\n     * @param {?} guard\n     * @param {?} router\n     */\n    function RouterModule(guard, router) {\n      _classCallCheck(this, RouterModule);\n    }\n    /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Options (see `ExtraOptions`):\n     * * `enableTracing` makes the router log all its internal events to the console.\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` disables the initial navigation.\n     * * `errorHandler` provides a custom error handler.\n     * * `preloadingStrategy` configures a preloading strategy (see `PreloadAllModules`).\n     * * `onSameUrlNavigation` configures how the router handles navigation to the current URL. See\n     * `ExtraOptions` for more details.\n     * * `paramsInheritanceStrategy` defines how the router merges params, data and resolved data\n     * from parent to child routes.\n     * @param {?} routes\n     * @param {?=} config\n     * @return {?}\n     */\n\n\n    _createClass(RouterModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot(routes, config) {\n        return {\n          ngModule: RouterModule,\n          providers: [ROUTER_PROVIDERS, provideRoutes(routes), {\n            provide: ROUTER_FORROOT_GUARD,\n            useFactory: provideForRootGuard,\n            deps: [[Router, new Optional(), new SkipSelf()]]\n          }, {\n            provide: ROUTER_CONFIGURATION,\n            useValue: config ? config : {}\n          }, {\n            provide: LocationStrategy,\n            useFactory: provideLocationStrategy,\n            deps: [PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION]\n          }, {\n            provide: RouterScroller,\n            useFactory: createRouterScroller,\n            deps: [Router, ViewportScroller, ROUTER_CONFIGURATION]\n          }, {\n            provide: PreloadingStrategy,\n            useExisting: config && config.preloadingStrategy ? config.preloadingStrategy : NoPreloading\n          }, {\n            provide: NgProbeToken,\n            multi: true,\n            useFactory: routerNgProbeToken\n          }, provideRouterInitializer()]\n        };\n      }\n      /**\n       * Creates a module with all the router directives and a provider registering routes.\n       * @param {?} routes\n       * @return {?}\n       */\n\n    }, {\n      key: \"forChild\",\n      value: function forChild(routes) {\n        return {\n          ngModule: RouterModule,\n          providers: [provideRoutes(routes)]\n        };\n      }\n    }]);\n\n    return RouterModule;\n  }();\n\n  RouterModule.ɵfac = function RouterModule_Factory(t) {\n    return new (t || RouterModule)(ɵngcc0.ɵɵinject(ROUTER_FORROOT_GUARD, 8), ɵngcc0.ɵɵinject(Router, 8));\n  };\n\n  RouterModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: RouterModule\n  });\n  RouterModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /** @nocollapse */\n\n  return RouterModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RouterModule, {\n    declarations: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, EmptyOutletComponent],\n    exports: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, EmptyOutletComponent]\n  });\n})();\n/**\n * @param {?} router\n * @param {?} viewportScroller\n * @param {?} config\n * @return {?}\n */\n\n\nfunction createRouterScroller(router, viewportScroller, config) {\n  if (config.scrollOffset) {\n    viewportScroller.setOffset(config.scrollOffset);\n  }\n\n  return new RouterScroller(router, viewportScroller, config);\n}\n/**\n * @param {?} platformLocationStrategy\n * @param {?} baseHref\n * @param {?=} options\n * @return {?}\n */\n\n\nfunction provideLocationStrategy(platformLocationStrategy, baseHref) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) : new PathLocationStrategy(platformLocationStrategy, baseHref);\n}\n/**\n * @param {?} router\n * @return {?}\n */\n\n\nfunction provideForRootGuard(router) {\n  if (router) {\n    throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n  }\n\n  return 'guarded';\n}\n/**\n * \\@description\n *\n * Registers routes.\n *\n * \\@usageNotes\n * ### Example\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n *\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction provideRoutes(routes) {\n  return [{\n    provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n    multi: true,\n    useValue: routes\n  }, {\n    provide: ROUTES,\n    multi: true,\n    useValue: routes\n  }];\n}\n/**\n * @param {?} ref\n * @param {?} urlSerializer\n * @param {?} contexts\n * @param {?} location\n * @param {?} injector\n * @param {?} loader\n * @param {?} compiler\n * @param {?} config\n * @param {?=} opts\n * @param {?=} urlHandlingStrategy\n * @param {?=} routeReuseStrategy\n * @return {?}\n */\n\n\nfunction setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config) {\n  var opts = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {};\n  var urlHandlingStrategy = arguments.length > 9 ? arguments[9] : undefined;\n  var routeReuseStrategy = arguments.length > 10 ? arguments[10] : undefined;\n\n  /** @type {?} */\n  var router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));\n\n  if (urlHandlingStrategy) {\n    router.urlHandlingStrategy = urlHandlingStrategy;\n  }\n\n  if (routeReuseStrategy) {\n    router.routeReuseStrategy = routeReuseStrategy;\n  }\n\n  if (opts.errorHandler) {\n    router.errorHandler = opts.errorHandler;\n  }\n\n  if (opts.malformedUriErrorHandler) {\n    router.malformedUriErrorHandler = opts.malformedUriErrorHandler;\n  }\n\n  if (opts.enableTracing) {\n    /** @type {?} */\n    var dom = ɵgetDOM();\n    router.events.subscribe(function (e) {\n      dom.logGroup(\"Router Event: \".concat(\n      /** @type {?} */\n      e.constructor.name));\n      dom.log(e.toString());\n      dom.log(e);\n      dom.logGroupEnd();\n    });\n  }\n\n  if (opts.onSameUrlNavigation) {\n    router.onSameUrlNavigation = opts.onSameUrlNavigation;\n  }\n\n  if (opts.paramsInheritanceStrategy) {\n    router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;\n  }\n\n  if (opts.urlUpdateStrategy) {\n    router.urlUpdateStrategy = opts.urlUpdateStrategy;\n  }\n\n  if (opts.relativeLinkResolution) {\n    router.relativeLinkResolution = opts.relativeLinkResolution;\n  }\n\n  return router;\n}\n/**\n * @param {?} router\n * @return {?}\n */\n\n\nfunction rootRoute(router) {\n  return router.routerState.root;\n}\n/**\n * To initialize the router properly we need to do in two steps:\n *\n * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if\n * a resolver or a guards executes asynchronously. Second, we need to actually run\n * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation\n * hook provided by the router to do that.\n *\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\n\n\nvar RouterInitializer = /*#__PURE__*/(function () {\n  var RouterInitializer = /*#__PURE__*/function () {\n    /**\n     * @param {?} injector\n     */\n    function RouterInitializer(injector) {\n      _classCallCheck(this, RouterInitializer);\n\n      this.injector = injector;\n      this.initNavigation = false;\n      this.resultOfPreactivationDone = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(RouterInitializer, [{\n      key: \"appInitializer\",\n      value: function appInitializer() {\n        var _this55 = this;\n\n        /** @type {?} */\n        var p = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));\n        return p.then(function () {\n          /** @type {?} */\n          var resolve =\n          /** @type {?} */\n          null;\n          /** @type {?} */\n\n          var res = new Promise(function (r) {\n            return resolve = r;\n          });\n          /** @type {?} */\n\n          var router = _this55.injector.get(Router);\n          /** @type {?} */\n\n\n          var opts = _this55.injector.get(ROUTER_CONFIGURATION);\n\n          if (_this55.isLegacyDisabled(opts) || _this55.isLegacyEnabled(opts)) {\n            resolve(true);\n          } else if (opts.initialNavigation === 'disabled') {\n            router.setUpLocationChangeListener();\n            resolve(true);\n          } else if (opts.initialNavigation === 'enabled') {\n            router.hooks.afterPreactivation = function () {\n              // only the initial navigation should be delayed\n              if (!_this55.initNavigation) {\n                _this55.initNavigation = true;\n                resolve(true);\n                return _this55.resultOfPreactivationDone; // subsequent navigations should not be delayed\n              } else {\n                return (\n                  /** @type {?} */\n                  of(null)\n                );\n              }\n            };\n\n            router.initialNavigation();\n          } else {\n            throw new Error(\"Invalid initialNavigation options: '\".concat(opts.initialNavigation, \"'\"));\n          }\n\n          return res;\n        });\n      }\n      /**\n       * @param {?} bootstrappedComponentRef\n       * @return {?}\n       */\n\n    }, {\n      key: \"bootstrapListener\",\n      value: function bootstrapListener(bootstrappedComponentRef) {\n        /** @type {?} */\n        var opts = this.injector.get(ROUTER_CONFIGURATION);\n        /** @type {?} */\n\n        var preloader = this.injector.get(RouterPreloader);\n        /** @type {?} */\n\n        var routerScroller = this.injector.get(RouterScroller);\n        /** @type {?} */\n\n        var router = this.injector.get(Router);\n        /** @type {?} */\n\n        var ref = this.injector.get(ApplicationRef);\n\n        if (bootstrappedComponentRef !== ref.components[0]) {\n          return;\n        }\n\n        if (this.isLegacyEnabled(opts)) {\n          router.initialNavigation();\n        } else if (this.isLegacyDisabled(opts)) {\n          router.setUpLocationChangeListener();\n        }\n\n        preloader.setUpPreloading();\n        routerScroller.init();\n        router.resetRootComponentType(ref.componentTypes[0]);\n        this.resultOfPreactivationDone.next(\n        /** @type {?} */\n        null);\n        this.resultOfPreactivationDone.complete();\n      }\n      /**\n       * @param {?} opts\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLegacyEnabled\",\n      value: function isLegacyEnabled(opts) {\n        return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true || opts.initialNavigation === undefined;\n      }\n      /**\n       * @param {?} opts\n       * @return {?}\n       */\n\n    }, {\n      key: \"isLegacyDisabled\",\n      value: function isLegacyDisabled(opts) {\n        return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;\n      }\n    }]);\n\n    return RouterInitializer;\n  }();\n\n  RouterInitializer.ɵfac = function RouterInitializer_Factory(t) {\n    return new (t || RouterInitializer)(ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  RouterInitializer.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: RouterInitializer,\n    factory: RouterInitializer.ɵfac\n  });\n  /** @nocollapse */\n\n  return RouterInitializer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @param {?} r\n * @return {?}\n */\n\n\nfunction getAppInitializer(r) {\n  return r.appInitializer.bind(r);\n}\n/**\n * @param {?} r\n * @return {?}\n */\n\n\nfunction getBootstrapListener(r) {\n  return r.bootstrapListener.bind(r);\n}\n/** *\n * A token for the router initializer that will be called after the app is bootstrapped.\n *\n * \\@experimental\n  @type {?} */\n\n\nvar ROUTER_INITIALIZER = /*#__PURE__*/new InjectionToken('Router Initializer');\n/**\n * @return {?}\n */\n\nfunction provideRouterInitializer() {\n  return [RouterInitializer, {\n    provide: APP_INITIALIZER,\n    multi: true,\n    useFactory: getAppInitializer,\n    deps: [RouterInitializer]\n  }, {\n    provide: ROUTER_INITIALIZER,\n    useFactory: getBootstrapListener,\n    deps: [RouterInitializer]\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useExisting: ROUTER_INITIALIZER\n  }];\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar VERSION = /*#__PURE__*/new Version('6.1.10');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ROUTER_FORROOT_GUARD as ɵangular_packages_router_router_a, RouterInitializer as ɵangular_packages_router_router_h, createRouterScroller as ɵangular_packages_router_router_c, getAppInitializer as ɵangular_packages_router_router_i, getBootstrapListener as ɵangular_packages_router_router_j, provideForRootGuard as ɵangular_packages_router_router_e, provideLocationStrategy as ɵangular_packages_router_router_d, provideRouterInitializer as ɵangular_packages_router_router_k, rootRoute as ɵangular_packages_router_router_g, routerNgProbeToken as ɵangular_packages_router_router_b, setupRouter as ɵangular_packages_router_router_f, RouterScroller as ɵangular_packages_router_router_n, Tree as ɵangular_packages_router_router_l, TreeNode as ɵangular_packages_router_router_m, RouterLink, RouterLinkWithHref, RouterLinkActive, RouterOutlet, ActivationEnd, ActivationStart, ChildActivationEnd, ChildActivationStart, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouterEvent, RoutesRecognized, Scroll, RouteReuseStrategy, Router, ROUTES, ROUTER_CONFIGURATION, ROUTER_INITIALIZER, RouterModule, provideRoutes, ChildrenOutletContexts, OutletContext, NoPreloading, PreloadAllModules, PreloadingStrategy, RouterPreloader, ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot, PRIMARY_OUTLET, convertToParamMap, UrlHandlingStrategy, DefaultUrlSerializer, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VERSION, EmptyOutletComponent as ɵEmptyOutletComponent, ROUTER_PROVIDERS as ɵROUTER_PROVIDERS, flatten as ɵflatten }; //# sourceMappingURL=router.js.map","map":null,"metadata":{},"sourceType":"module"}